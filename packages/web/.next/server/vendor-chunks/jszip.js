"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jszip";
exports.ids = ["vendor-chunks/jszip"];
exports.modules = {

/***/ "(ssr)/../../node_modules/jszip/lib/base64.js":
/*!**********************************************!*\
  !*** ../../node_modules/jszip/lib/base64.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while(i < input.length){\n        remainingBytes = len - i;\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n    }\n    return output.join(\"\");\n};\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n    var dataUrlPrefix = \"data:\";\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n    input = input.replace(/[^A-Za-z0-9+/=]/g, \"\");\n    var totalLength = input.length * 3 / 4;\n    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength | 0);\n    } else {\n        output = new Array(totalLength | 0);\n    }\n    while(i < input.length){\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output[resultIndex++] = chr1;\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n    }\n    return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyw0REFBUztBQUM3QixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyxnRUFBVztBQUNqQyxtQkFBbUI7QUFDbkIsSUFBSUUsVUFBVTtBQUdkLDZCQUE2QjtBQUM3QkMsY0FBYyxHQUFHLFNBQVNFLEtBQUs7SUFDM0IsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTUM7SUFDeEMsSUFBSUMsSUFBSSxHQUFHQyxNQUFNVixNQUFNVyxNQUFNLEVBQUVDLGlCQUFpQkY7SUFFaEQsSUFBSUcsVUFBVW5CLE1BQU1vQixTQUFTLENBQUNkLFdBQVc7SUFDekMsTUFBT1MsSUFBSVQsTUFBTVcsTUFBTSxDQUFFO1FBQ3JCQyxpQkFBaUJGLE1BQU1EO1FBRXZCLElBQUksQ0FBQ0ksU0FBUztZQUNWWCxPQUFPRixNQUFNZSxVQUFVLENBQUNOO1lBQ3hCTixPQUFPTSxJQUFJQyxNQUFNVixNQUFNZSxVQUFVLENBQUNOLE9BQU87WUFDekNMLE9BQU9LLElBQUlDLE1BQU1WLE1BQU1lLFVBQVUsQ0FBQ04sT0FBTztRQUM3QyxPQUFPO1lBQ0hQLE9BQU9GLEtBQUssQ0FBQ1MsSUFBSTtZQUNqQk4sT0FBT00sSUFBSUMsTUFBTVYsS0FBSyxDQUFDUyxJQUFJLEdBQUc7WUFDOUJMLE9BQU9LLElBQUlDLE1BQU1WLEtBQUssQ0FBQ1MsSUFBSSxHQUFHO1FBQ2xDO1FBRUFKLE9BQU9ILFFBQVE7UUFDZkksT0FBTyxDQUFFSixPQUFPLE1BQU0sSUFBTUMsUUFBUTtRQUNwQ0ksT0FBT0ssaUJBQWlCLElBQUssQ0FBRVQsT0FBTyxFQUFDLEtBQU0sSUFBTUMsUUFBUSxJQUFNO1FBQ2pFSSxPQUFPSSxpQkFBaUIsSUFBS1IsT0FBTyxLQUFNO1FBRTFDSCxPQUFPZSxJQUFJLENBQUNuQixRQUFRb0IsTUFBTSxDQUFDWixRQUFRUixRQUFRb0IsTUFBTSxDQUFDWCxRQUFRVCxRQUFRb0IsTUFBTSxDQUFDVixRQUFRVixRQUFRb0IsTUFBTSxDQUFDVDtJQUVwRztJQUVBLE9BQU9QLE9BQU9pQixJQUFJLENBQUM7QUFDdkI7QUFFQSw2QkFBNkI7QUFDN0JwQixjQUFjLEdBQUcsU0FBU0UsS0FBSztJQUMzQixJQUFJRSxNQUFNQyxNQUFNQztJQUNoQixJQUFJQyxNQUFNQyxNQUFNQyxNQUFNQztJQUN0QixJQUFJQyxJQUFJLEdBQUdXLGNBQWM7SUFFekIsSUFBSUMsZ0JBQWdCO0lBRXBCLElBQUlyQixNQUFNc0IsTUFBTSxDQUFDLEdBQUdELGNBQWNWLE1BQU0sTUFBTVUsZUFBZTtRQUN6RCxpREFBaUQ7UUFDakQsNkRBQTZEO1FBQzdELGlDQUFpQztRQUNqQyxtRUFBbUU7UUFDbkUsdUVBQXVFO1FBQ3ZFLG9CQUFvQjtRQUNwQixNQUFNLElBQUlFLE1BQU07SUFDcEI7SUFFQXZCLFFBQVFBLE1BQU13QixPQUFPLENBQUMsb0JBQW9CO0lBRTFDLElBQUlDLGNBQWN6QixNQUFNVyxNQUFNLEdBQUcsSUFBSTtJQUNyQyxJQUFHWCxNQUFNaUIsTUFBTSxDQUFDakIsTUFBTVcsTUFBTSxHQUFHLE9BQU9kLFFBQVFvQixNQUFNLENBQUMsS0FBSztRQUN0RFE7SUFDSjtJQUNBLElBQUd6QixNQUFNaUIsTUFBTSxDQUFDakIsTUFBTVcsTUFBTSxHQUFHLE9BQU9kLFFBQVFvQixNQUFNLENBQUMsS0FBSztRQUN0RFE7SUFDSjtJQUNBLElBQUlBLGNBQWMsTUFBTSxHQUFHO1FBQ3ZCLG1FQUFtRTtRQUNuRSxzQ0FBc0M7UUFDdEMsc0NBQXNDO1FBQ3RDLHNFQUFzRTtRQUN0RSw0QkFBNEI7UUFDNUIsNERBQTREO1FBQzVELE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtJQUNBLElBQUl0QjtJQUNKLElBQUlMLFFBQVE4QixVQUFVLEVBQUU7UUFDcEJ6QixTQUFTLElBQUkwQixXQUFXRixjQUFZO0lBQ3hDLE9BQU87UUFDSHhCLFNBQVMsSUFBSTJCLE1BQU1ILGNBQVk7SUFDbkM7SUFFQSxNQUFPaEIsSUFBSVQsTUFBTVcsTUFBTSxDQUFFO1FBRXJCTixPQUFPUixRQUFRZ0MsT0FBTyxDQUFDN0IsTUFBTWlCLE1BQU0sQ0FBQ1I7UUFDcENILE9BQU9ULFFBQVFnQyxPQUFPLENBQUM3QixNQUFNaUIsTUFBTSxDQUFDUjtRQUNwQ0YsT0FBT1YsUUFBUWdDLE9BQU8sQ0FBQzdCLE1BQU1pQixNQUFNLENBQUNSO1FBQ3BDRCxPQUFPWCxRQUFRZ0MsT0FBTyxDQUFDN0IsTUFBTWlCLE1BQU0sQ0FBQ1I7UUFFcENQLE9BQU8sUUFBUyxJQUFNSSxRQUFRO1FBQzlCSCxPQUFPLENBQUVHLE9BQU8sRUFBQyxLQUFNLElBQU1DLFFBQVE7UUFDckNILE9BQU8sQ0FBRUcsT0FBTyxNQUFNLElBQUtDO1FBRTNCUCxNQUFNLENBQUNtQixjQUFjLEdBQUdsQjtRQUV4QixJQUFJSyxTQUFTLElBQUk7WUFDYk4sTUFBTSxDQUFDbUIsY0FBYyxHQUFHakI7UUFDNUI7UUFDQSxJQUFJSyxTQUFTLElBQUk7WUFDYlAsTUFBTSxDQUFDbUIsY0FBYyxHQUFHaEI7UUFDNUI7SUFFSjtJQUVBLE9BQU9IO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcz8zMWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG4vLyBwcml2YXRlIHByb3BlcnR5XG52YXIgX2tleVN0ciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcblxuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBlbmNvZGluZ1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMywgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICB2YXIgaSA9IDAsIGxlbiA9IGlucHV0Lmxlbmd0aCwgcmVtYWluaW5nQnl0ZXMgPSBsZW47XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG4gICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmVtYWluaW5nQnl0ZXMgPSBsZW4gLSBpO1xuXG4gICAgICAgIGlmICghaXNBcnJheSkge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKyspIDogMDtcbiAgICAgICAgICAgIGNocjMgPSBpIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKyspIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgICAgIGNocjMgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcbiAgICAgICAgZW5jMyA9IHJlbWFpbmluZ0J5dGVzID4gMSA/ICgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSkgOiA2NDtcbiAgICAgICAgZW5jNCA9IHJlbWFpbmluZ0J5dGVzID4gMiA/IChjaHIzICYgNjMpIDogNjQ7XG5cbiAgICAgICAgb3V0cHV0LnB1c2goX2tleVN0ci5jaGFyQXQoZW5jMSkgKyBfa2V5U3RyLmNoYXJBdChlbmMyKSArIF9rZXlTdHIuY2hhckF0KGVuYzMpICsgX2tleVN0ci5jaGFyQXQoZW5jNCkpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufTtcblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZGVjb2RpbmdcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICB2YXIgaSA9IDAsIHJlc3VsdEluZGV4ID0gMDtcblxuICAgIHZhciBkYXRhVXJsUHJlZml4ID0gXCJkYXRhOlwiO1xuXG4gICAgaWYgKGlucHV0LnN1YnN0cigwLCBkYXRhVXJsUHJlZml4Lmxlbmd0aCkgPT09IGRhdGFVcmxQcmVmaXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGNvbW1vbiBlcnJvcjogcGVvcGxlIGdpdmUgYSBkYXRhIHVybFxuICAgICAgICAvLyAoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SLi4uKSB3aXRoIGEge2Jhc2U2NDogdHJ1ZX0gYW5kXG4gICAgICAgIC8vIHdvbmRlcnMgd2h5IHRoaW5ncyBkb24ndCB3b3JrLlxuICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgdGhlIHN0cmluZyBpbnB1dCBsb29rcyBsaWtlIGEgZGF0YSB1cmwgYnV0IHdlXG4gICAgICAgIC8vICpjYW4ndCogYmUgc3VyZSBpdCBpcyBvbmU6IHJlbW92aW5nIGV2ZXJ5dGhpbmcgdXAgdG8gdGhlIGNvbW1hIHdvdWxkXG4gICAgICAgIC8vIGJlIHRvbyBkYW5nZXJvdXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBpdCBsb29rcyBsaWtlIGEgZGF0YSB1cmwuXCIpO1xuICAgIH1cblxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTkrLz1dL2csIFwiXCIpO1xuXG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gaW5wdXQubGVuZ3RoICogMyAvIDQ7XG4gICAgaWYoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBfa2V5U3RyLmNoYXJBdCg2NCkpIHtcbiAgICAgICAgdG90YWxMZW5ndGgtLTtcbiAgICB9XG4gICAgaWYoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aCAtIDIpID09PSBfa2V5U3RyLmNoYXJBdCg2NCkpIHtcbiAgICAgICAgdG90YWxMZW5ndGgtLTtcbiAgICB9XG4gICAgaWYgKHRvdGFsTGVuZ3RoICUgMSAhPT0gMCkge1xuICAgICAgICAvLyB0b3RhbExlbmd0aCBpcyBub3QgYW4gaW50ZWdlciwgdGhlIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBhIHZhbGlkXG4gICAgICAgIC8vIGJhc2U2NCBjb250ZW50LiBUaGF0IGNhbiBoYXBwZW4gaWY6XG4gICAgICAgIC8vIC0gdGhlIGlucHV0IGlzIG5vdCBhIGJhc2U2NCBjb250ZW50XG4gICAgICAgIC8vIC0gdGhlIGlucHV0IGlzICphbG1vc3QqIGEgYmFzZTY0IGNvbnRlbnQsIHdpdGggYSBleHRyYSBjaGFycyBhdCB0aGVcbiAgICAgICAgLy8gICBiZWdpbm5pbmcgb3IgYXQgdGhlIGVuZFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCB1c2VzIGEgYmFzZTY0IHZhcmlhbnQgKGJhc2U2NHVybCBmb3IgZXhhbXBsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGJhZCBjb250ZW50IGxlbmd0aC5cIik7XG4gICAgfVxuICAgIHZhciBvdXRwdXQ7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcblxuICAgICAgICBlbmMxID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzMgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmM0ID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcblxuICAgICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG4gICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjE7XG5cbiAgICAgICAgaWYgKGVuYzMgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwic3VwcG9ydCIsIl9rZXlTdHIiLCJleHBvcnRzIiwiZW5jb2RlIiwiaW5wdXQiLCJvdXRwdXQiLCJjaHIxIiwiY2hyMiIsImNocjMiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwiaSIsImxlbiIsImxlbmd0aCIsInJlbWFpbmluZ0J5dGVzIiwiaXNBcnJheSIsImdldFR5cGVPZiIsImNoYXJDb2RlQXQiLCJwdXNoIiwiY2hhckF0Iiwiam9pbiIsImRlY29kZSIsInJlc3VsdEluZGV4IiwiZGF0YVVybFByZWZpeCIsInN1YnN0ciIsIkVycm9yIiwicmVwbGFjZSIsInRvdGFsTGVuZ3RoIiwidWludDhhcnJheSIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/base64.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/compressedObject.js":
/*!********************************************************!*\
  !*** ../../node_modules/jszip/lib/compressedObject.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/../../node_modules/jszip/lib/external.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/DataWorker.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/../../node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ \"(ssr)/../../node_modules/jszip/lib/stream/DataLengthProbe.js\");\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */ function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */ getContentWorker: function() {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe(\"data_length\"));\n        var that = this;\n        worker.on(\"end\", function() {\n            if (this.streamInfo[\"data_length\"] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */ getCompressedWorker: function() {\n        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n    }\n};\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */ CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe(\"uncompressedSize\")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe(\"compressedSize\")).withStreamInfo(\"compression\", compression);\n};\nmodule.exports = CompressedObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2VkT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsV0FBV0MsbUJBQU9BLENBQUMsa0VBQVk7QUFDbkMsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQXFCO0FBQzlDLElBQUlFLGFBQWFGLG1CQUFPQSxDQUFDLG9GQUFxQjtBQUM5QyxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLDhGQUEwQjtBQUV4RDs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNJLGlCQUFpQkMsY0FBYyxFQUFFQyxnQkFBZ0IsRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUVDLElBQUk7SUFDaEYsSUFBSSxDQUFDSixjQUFjLEdBQUdBO0lBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdBO0lBQ3hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNiLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNuQixJQUFJLENBQUNFLGlCQUFpQixHQUFHRDtBQUM3QjtBQUVBTCxpQkFBaUJPLFNBQVMsR0FBRztJQUN6Qjs7O0tBR0MsR0FDREMsa0JBQWtCO1FBQ2QsSUFBSUMsU0FBUyxJQUFJWixXQUFXRixTQUFTZSxPQUFPLENBQUNDLE9BQU8sQ0FBQyxJQUFJLENBQUNMLGlCQUFpQixHQUN0RU0sSUFBSSxDQUFDLElBQUksQ0FBQ1IsV0FBVyxDQUFDUyxnQkFBZ0IsSUFDdENELElBQUksQ0FBQyxJQUFJYixnQkFBZ0I7UUFFOUIsSUFBSWUsT0FBTyxJQUFJO1FBQ2ZMLE9BQU9NLEVBQUUsQ0FBQyxPQUFPO1lBQ2IsSUFBSSxJQUFJLENBQUNDLFVBQVUsQ0FBQyxjQUFjLEtBQUtGLEtBQUtaLGdCQUFnQixFQUFFO2dCQUMxRCxNQUFNLElBQUllLE1BQU07WUFDcEI7UUFDSjtRQUNBLE9BQU9SO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRFMscUJBQXFCO1FBQ2pCLE9BQU8sSUFBSXJCLFdBQVdGLFNBQVNlLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ0wsaUJBQWlCLEdBQ2hFYSxjQUFjLENBQUMsa0JBQWtCLElBQUksQ0FBQ2xCLGNBQWMsRUFDcERrQixjQUFjLENBQUMsb0JBQW9CLElBQUksQ0FBQ2pCLGdCQUFnQixFQUN4RGlCLGNBQWMsQ0FBQyxTQUFTLElBQUksQ0FBQ2hCLEtBQUssRUFDbENnQixjQUFjLENBQUMsZUFBZSxJQUFJLENBQUNmLFdBQVc7SUFFdkQ7QUFDSjtBQUVBOzs7Ozs7O0NBT0MsR0FDREosaUJBQWlCb0IsZ0JBQWdCLEdBQUcsU0FBVUMsa0JBQWtCLEVBQUVqQixXQUFXLEVBQUVrQixrQkFBa0I7SUFDN0YsT0FBT0QsbUJBQ0ZULElBQUksQ0FBQyxJQUFJZCxjQUNUYyxJQUFJLENBQUMsSUFBSWIsZ0JBQWdCLHFCQUN6QmEsSUFBSSxDQUFDUixZQUFZbUIsY0FBYyxDQUFDRCxxQkFDaENWLElBQUksQ0FBQyxJQUFJYixnQkFBZ0IsbUJBQ3pCb0IsY0FBYyxDQUFDLGVBQWVmO0FBQ3ZDO0FBRUFvQixPQUFPQyxPQUFPLEdBQUd6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcz8yMjY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIik7XG52YXIgQ3JjMzJQcm9iZSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9DcmMzMlByb2JlXCIpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmVcIik7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgRGF0YVdvcmtlcihleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpXG4gICAgICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJkYXRhX2xlbmd0aFwiKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB3b3JrZXIub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtSW5mb1tcImRhdGFfbGVuZ3RoXCJdICE9PSB0aGF0LnVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdvcmtlciB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRXb3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsIHRoaXMuY29tcHJlc3NlZFNpemUpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJ1bmNvbXByZXNzZWRTaXplXCIsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0aGlzLmNvbXByZXNzaW9uKVxuICAgICAgICA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFpbiB0aGUgZ2l2ZW4gd29ya2VyIHdpdGggb3RoZXIgd29ya2VycyB0byBjb21wcmVzcyB0aGUgY29udGVudCB3aXRoIHRoZVxuICogZ2l2ZW4gY29tcHJlc3Npb24uXG4gKiBAcGFyYW0ge0dlbmVyaWNXb3JrZXJ9IHVuY29tcHJlc3NlZFdvcmtlciB0aGUgd29ya2VyIHRvIHBpcGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgbmV3IHdvcmtlciBjb21wcmVzc2luZyB0aGUgY29udGVudC5cbiAqL1xuQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tID0gZnVuY3Rpb24gKHVuY29tcHJlc3NlZFdvcmtlciwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiB1bmNvbXByZXNzZWRXb3JrZXJcbiAgICAgICAgLnBpcGUobmV3IENyYzMyUHJvYmUoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgICAgIC5waXBlKGNvbXByZXNzaW9uLmNvbXByZXNzV29ya2VyKGNvbXByZXNzaW9uT3B0aW9ucykpXG4gICAgICAgIC5waXBlKG5ldyBEYXRhTGVuZ3RoUHJvYmUoXCJjb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIl0sIm5hbWVzIjpbImV4dGVybmFsIiwicmVxdWlyZSIsIkRhdGFXb3JrZXIiLCJDcmMzMlByb2JlIiwiRGF0YUxlbmd0aFByb2JlIiwiQ29tcHJlc3NlZE9iamVjdCIsImNvbXByZXNzZWRTaXplIiwidW5jb21wcmVzc2VkU2l6ZSIsImNyYzMyIiwiY29tcHJlc3Npb24iLCJkYXRhIiwiY29tcHJlc3NlZENvbnRlbnQiLCJwcm90b3R5cGUiLCJnZXRDb250ZW50V29ya2VyIiwid29ya2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwaXBlIiwidW5jb21wcmVzc1dvcmtlciIsInRoYXQiLCJvbiIsInN0cmVhbUluZm8iLCJFcnJvciIsImdldENvbXByZXNzZWRXb3JrZXIiLCJ3aXRoU3RyZWFtSW5mbyIsImNyZWF0ZVdvcmtlckZyb20iLCJ1bmNvbXByZXNzZWRXb3JrZXIiLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJjb21wcmVzc1dvcmtlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/compressedObject.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/compressions.js":
/*!****************************************************!*\
  !*** ../../node_modules/jszip/lib/compressions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker: function() {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker: function() {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"(ssr)/../../node_modules/jszip/lib/flate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxnQkFBZ0JDLG1CQUFPQSxDQUFDLDBGQUF3QjtBQUVwREMsYUFBYSxHQUFHO0lBQ1pFLE9BQU87SUFDUEMsZ0JBQWlCO1FBQ2IsT0FBTyxJQUFJTCxjQUFjO0lBQzdCO0lBQ0FNLGtCQUFtQjtRQUNmLE9BQU8sSUFBSU4sY0FBYztJQUM3QjtBQUNKO0FBQ0FFLG1HQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3Npb25zLmpzPzAxMDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbmV4cG9ydHMuU1RPUkUgPSB7XG4gICAgbWFnaWM6IFwiXFx4MDBcXHgwMFwiLFxuICAgIGNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBjb21wcmVzc2lvblwiKTtcbiAgICB9LFxuICAgIHVuY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGRlY29tcHJlc3Npb25cIik7XG4gICAgfVxufTtcbmV4cG9ydHMuREVGTEFURSA9IHJlcXVpcmUoXCIuL2ZsYXRlXCIpO1xuIl0sIm5hbWVzIjpbIkdlbmVyaWNXb3JrZXIiLCJyZXF1aXJlIiwiZXhwb3J0cyIsIlNUT1JFIiwibWFnaWMiLCJjb21wcmVzc1dvcmtlciIsInVuY29tcHJlc3NXb3JrZXIiLCJERUZMQVRFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/compressions.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/crc32.js":
/*!*********************************************!*\
  !*** ../../node_modules/jszip/lib/crc32.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\n// That's all for the pako functions.\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */ function crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    if (isArray) {\n        return crc32(crc | 0, input, input.length, 0);\n    } else {\n        return crc32str(crc | 0, input, input.length, 0);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jcmMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLDREQUFTO0FBRTdCOzs7Q0FHQyxHQUVELHdEQUF3RDtBQUN4RCxTQUFTQztJQUNMLElBQUlDLEdBQUdDLFFBQVEsRUFBRTtJQUVqQixJQUFJLElBQUlDLElBQUcsR0FBR0EsSUFBSSxLQUFLQSxJQUFJO1FBQ3ZCRixJQUFJRTtRQUNKLElBQUksSUFBSUMsSUFBRyxHQUFHQSxJQUFJLEdBQUdBLElBQUk7WUFDckJILElBQUssSUFBRyxJQUFNLGFBQWNBLE1BQU0sSUFBT0EsTUFBTTtRQUNuRDtRQUNBQyxLQUFLLENBQUNDLEVBQUUsR0FBR0Y7SUFDZjtJQUVBLE9BQU9DO0FBQ1g7QUFFQSw4REFBOEQ7QUFDOUQsSUFBSUcsV0FBV0w7QUFHZixTQUFTTSxNQUFNQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQzdCLElBQUlDLElBQUlOLFVBQVVPLE1BQU1GLE1BQU1EO0lBRTlCRixNQUFNQSxNQUFPLENBQUM7SUFFZCxJQUFLLElBQUlNLElBQUlILEtBQUtHLElBQUlELEtBQUtDLElBQU07UUFDN0JOLE1BQU0sUUFBUyxJQUFLSSxDQUFDLENBQUMsQ0FBQ0osTUFBTUMsR0FBRyxDQUFDSyxFQUFFLElBQUksS0FBSztJQUNoRDtJQUVBLE9BQVFOLE1BQU8sQ0FBQyxHQUFLLFNBQVM7QUFDbEM7QUFFQSxxQ0FBcUM7QUFFckM7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU08sU0FBU1AsR0FBRyxFQUFFUSxHQUFHLEVBQUVOLEdBQUcsRUFBRUMsR0FBRztJQUNoQyxJQUFJQyxJQUFJTixVQUFVTyxNQUFNRixNQUFNRDtJQUU5QkYsTUFBTUEsTUFBTyxDQUFDO0lBRWQsSUFBSyxJQUFJTSxJQUFJSCxLQUFLRyxJQUFJRCxLQUFLQyxJQUFNO1FBQzdCTixNQUFNLFFBQVMsSUFBS0ksQ0FBQyxDQUFDLENBQUNKLE1BQU1RLElBQUlDLFVBQVUsQ0FBQ0gsRUFBQyxJQUFLLEtBQUs7SUFDM0Q7SUFFQSxPQUFRTixNQUFPLENBQUMsR0FBSyxTQUFTO0FBQ2xDO0FBRUFVLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxhQUFhQyxLQUFLLEVBQUViLEdBQUc7SUFDN0MsSUFBSSxPQUFPYSxVQUFVLGVBQWUsQ0FBQ0EsTUFBTUMsTUFBTSxFQUFFO1FBQy9DLE9BQU87SUFDWDtJQUVBLElBQUlDLFVBQVV4QixNQUFNeUIsU0FBUyxDQUFDSCxXQUFXO0lBRXpDLElBQUdFLFNBQVM7UUFDUixPQUFPaEIsTUFBTUMsTUFBSSxHQUFHYSxPQUFPQSxNQUFNQyxNQUFNLEVBQUU7SUFDN0MsT0FBTztRQUNILE9BQU9QLFNBQVNQLE1BQUksR0FBR2EsT0FBT0EsTUFBTUMsTUFBTSxFQUFFO0lBQ2hEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzP2E5YWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3psaWIvY3JjMzIuanNcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gICAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgICBmb3IodmFyIG4gPTA7IG4gPCAyNTY7IG4rKyl7XG4gICAgICAgIGMgPSBuO1xuICAgICAgICBmb3IodmFyIGsgPTA7IGsgPCA4OyBrKyspe1xuICAgICAgICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY3JjMzIgb2YgYSBzdHJpbmcuXG4gKiBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyB0aGUgZnVuY3Rpb24gY3JjMzIsIGJ1dCBmb3Igc3RyaW5ncy4gVXNpbmcgdGhlXG4gKiBzYW1lIGZ1bmN0aW9uIGZvciB0aGUgdHdvIHVzZSBjYXNlcyBsZWFkcyB0byBob3JyaWJsZSBwZXJmb3JtYW5jZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY3JjIHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgY3JjLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSBjcmMzMiBjb21wdXRhdGlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbXB1dGVkIGNyYzMyLlxuICovXG5mdW5jdGlvbiBjcmMzMnN0cihjcmMsIHN0ciwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdO1xuICAgIH1cblxuICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyYzMyd3JhcHBlcihpbnB1dCwgY3JjKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcblxuICAgIGlmKGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JjMzJzdHIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwibWFrZVRhYmxlIiwiYyIsInRhYmxlIiwibiIsImsiLCJjcmNUYWJsZSIsImNyYzMyIiwiY3JjIiwiYnVmIiwibGVuIiwicG9zIiwidCIsImVuZCIsImkiLCJjcmMzMnN0ciIsInN0ciIsImNoYXJDb2RlQXQiLCJtb2R1bGUiLCJleHBvcnRzIiwiY3JjMzJ3cmFwcGVyIiwiaW5wdXQiLCJsZW5ndGgiLCJpc0FycmF5IiwiZ2V0VHlwZU9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/crc32.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/defaults.js":
/*!************************************************!*\
  !*** ../../node_modules/jszip/lib/defaults.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9kZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxjQUFjLEdBQUc7QUFDakJBLGNBQWMsR0FBRztBQUNqQkEsV0FBVyxHQUFHO0FBQ2RBLHFCQUFxQixHQUFHO0FBQ3hCQSxZQUFZLEdBQUc7QUFDZkEsbUJBQW1CLEdBQUc7QUFDdEJBLDBCQUEwQixHQUFHO0FBQzdCQSxlQUFlLEdBQUc7QUFDbEJBLHVCQUF1QixHQUFHO0FBQzFCQSxzQkFBc0IsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZGVmYXVsdHMuanM/ZGFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuYmFzZTY0ID0gZmFsc2U7XG5leHBvcnRzLmJpbmFyeSA9IGZhbHNlO1xuZXhwb3J0cy5kaXIgPSBmYWxzZTtcbmV4cG9ydHMuY3JlYXRlRm9sZGVycyA9IHRydWU7XG5leHBvcnRzLmRhdGUgPSBudWxsO1xuZXhwb3J0cy5jb21wcmVzc2lvbiA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uT3B0aW9ucyA9IG51bGw7XG5leHBvcnRzLmNvbW1lbnQgPSBudWxsO1xuZXhwb3J0cy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuZXhwb3J0cy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImJhc2U2NCIsImJpbmFyeSIsImRpciIsImNyZWF0ZUZvbGRlcnMiLCJkYXRlIiwiY29tcHJlc3Npb24iLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJjb21tZW50IiwidW5peFBlcm1pc3Npb25zIiwiZG9zUGVybWlzc2lvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/defaults.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/external.js":
/*!************************************************!*\
  !*** ../../node_modules/jszip/lib/external.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = __webpack_require__(/*! lie */ \"(ssr)/../../node_modules/lie/lib/index.js\");\n}\n/**\n * Let the user use/change some implementations.\n */ module.exports = {\n    Promise: ES6Promise\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLGdDQUFnQztBQUNoQyw4RUFBOEU7QUFDOUUsMkVBQTJFO0FBQzNFLElBQUlBLGFBQWE7QUFDakIsSUFBSSxPQUFPQyxZQUFZLGFBQWE7SUFDaENELGFBQWFDO0FBQ2pCLE9BQU87SUFDSEQsYUFBYUUsbUJBQU9BLENBQUMsc0RBQUs7QUFDOUI7QUFFQTs7Q0FFQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUc7SUFDYkgsU0FBU0Q7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZXh0ZXJuYWwuanM/MTVmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gbG9hZCB0aGUgZ2xvYmFsIG9iamVjdCBmaXJzdDpcbi8vIC0gaXQgc2hvdWxkIGJlIGJldHRlciBpbnRlZ3JhdGVkIGluIHRoZSBzeXN0ZW0gKHVuaGFuZGxlZFJlamVjdGlvbiBpbiBub2RlKVxuLy8gLSB0aGUgZW52aXJvbm1lbnQgbWF5IGhhdmUgYSBjdXN0b20gUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiAoc2VlIHpvbmUuanMpXG52YXIgRVM2UHJvbWlzZSA9IG51bGw7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBFUzZQcm9taXNlID0gUHJvbWlzZTtcbn0gZWxzZSB7XG4gICAgRVM2UHJvbWlzZSA9IHJlcXVpcmUoXCJsaWVcIik7XG59XG5cbi8qKlxuICogTGV0IHRoZSB1c2VyIHVzZS9jaGFuZ2Ugc29tZSBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFByb21pc2U6IEVTNlByb21pc2Vcbn07XG4iXSwibmFtZXMiOlsiRVM2UHJvbWlzZSIsIlByb21pc2UiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/external.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/flate.js":
/*!*********************************************!*\
  !*** ../../node_modules/jszip/lib/flate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar USE_TYPEDARRAY = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Uint32Array !== \"undefined\";\nvar pako = __webpack_require__(/*! pako */ \"(ssr)/../../node_modules/pako/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\nexports.magic = \"\\b\\x00\";\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */ function FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\nutils.inherits(FlateWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ FlateWorker.prototype.processChunk = function(chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n/**\n * @see GenericWorker.flush\n */ FlateWorker.prototype.flush = function() {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */ FlateWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */ FlateWorker.prototype._createPako = function() {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data: data,\n            meta: self.meta\n        });\n    };\n};\nexports.compressWorker = function(compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function() {\n    return new FlateWorker(\"Inflate\", {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGlCQUFpQixPQUFRQyxlQUFlLGVBQWlCLE9BQU9DLGdCQUFnQixlQUFpQixPQUFPQyxnQkFBZ0I7QUFFNUgsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUMsb0RBQU07QUFDekIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMsNERBQVM7QUFDN0IsSUFBSUUsZ0JBQWdCRixtQkFBT0EsQ0FBQywwRkFBd0I7QUFFcEQsSUFBSUcsYUFBYVIsaUJBQWlCLGVBQWU7QUFFakRTLGFBQWEsR0FBRztBQUVoQjs7Ozs7Q0FLQyxHQUNELFNBQVNFLFlBQVlDLE1BQU0sRUFBRUMsT0FBTztJQUNoQ04sY0FBY08sSUFBSSxDQUFDLElBQUksRUFBRSxpQkFBaUJGO0lBRTFDLElBQUksQ0FBQ0csS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxXQUFXLEdBQUdKO0lBQ25CLElBQUksQ0FBQ0ssWUFBWSxHQUFHSjtJQUNwQixpREFBaUQ7SUFDakQsaURBQWlEO0lBQ2pELElBQUksQ0FBQ0ssSUFBSSxHQUFHLENBQUM7QUFDakI7QUFFQVosTUFBTWEsUUFBUSxDQUFDUixhQUFhSjtBQUU1Qjs7Q0FFQyxHQUNESSxZQUFZUyxTQUFTLENBQUNDLFlBQVksR0FBRyxTQUFVQyxLQUFLO0lBQ2hELElBQUksQ0FBQ0osSUFBSSxHQUFHSSxNQUFNSixJQUFJO0lBQ3RCLElBQUksSUFBSSxDQUFDSCxLQUFLLEtBQUssTUFBTTtRQUNyQixJQUFJLENBQUNRLFdBQVc7SUFDcEI7SUFDQSxJQUFJLENBQUNSLEtBQUssQ0FBQ1MsSUFBSSxDQUFDbEIsTUFBTW1CLFdBQVcsQ0FBQ2pCLFlBQVljLE1BQU1JLElBQUksR0FBRztBQUMvRDtBQUVBOztDQUVDLEdBQ0RmLFlBQVlTLFNBQVMsQ0FBQ08sS0FBSyxHQUFHO0lBQzFCcEIsY0FBY2EsU0FBUyxDQUFDTyxLQUFLLENBQUNiLElBQUksQ0FBQyxJQUFJO0lBQ3ZDLElBQUksSUFBSSxDQUFDQyxLQUFLLEtBQUssTUFBTTtRQUNyQixJQUFJLENBQUNRLFdBQVc7SUFDcEI7SUFDQSxJQUFJLENBQUNSLEtBQUssQ0FBQ1MsSUFBSSxDQUFDLEVBQUUsRUFBRTtBQUN4QjtBQUNBOztDQUVDLEdBQ0RiLFlBQVlTLFNBQVMsQ0FBQ1EsT0FBTyxHQUFHO0lBQzVCckIsY0FBY2EsU0FBUyxDQUFDUSxPQUFPLENBQUNkLElBQUksQ0FBQyxJQUFJO0lBQ3pDLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0FBQ2pCO0FBRUE7Ozs7O0NBS0MsR0FDREosWUFBWVMsU0FBUyxDQUFDRyxXQUFXLEdBQUc7SUFDaEMsSUFBSSxDQUFDUixLQUFLLEdBQUcsSUFBSVgsSUFBSSxDQUFDLElBQUksQ0FBQ1ksV0FBVyxDQUFDLENBQUM7UUFDcENhLEtBQUs7UUFDTEMsT0FBTyxJQUFJLENBQUNiLFlBQVksQ0FBQ2EsS0FBSyxJQUFJLENBQUMsRUFBRSxzQkFBc0I7SUFDL0Q7SUFDQSxJQUFJQyxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNoQixLQUFLLENBQUNpQixNQUFNLEdBQUcsU0FBU04sSUFBSTtRQUM3QkssS0FBS1AsSUFBSSxDQUFDO1lBQ05FLE1BQU9BO1lBQ1BSLE1BQU9hLEtBQUtiLElBQUk7UUFDcEI7SUFDSjtBQUNKO0FBRUFULHNCQUFzQixHQUFHLFNBQVV5QixrQkFBa0I7SUFDakQsT0FBTyxJQUFJdkIsWUFBWSxXQUFXdUI7QUFDdEM7QUFDQXpCLHdCQUF3QixHQUFHO0lBQ3ZCLE9BQU8sSUFBSUUsWUFBWSxXQUFXLENBQUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzPzE0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVVNFX1RZUEVEQVJSQVkgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgVWludDE2QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpO1xuXG52YXIgcGFrbyA9IHJlcXVpcmUoXCJwYWtvXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG52YXIgQVJSQVlfVFlQRSA9IFVTRV9UWVBFREFSUkFZID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG5cbmV4cG9ydHMubWFnaWMgPSBcIlxceDA4XFx4MDBcIjtcblxuLyoqXG4gKiBDcmVhdGUgYSB3b3JrZXIgdGhhdCB1c2VzIHBha28gdG8gaW5mbGF0ZS9kZWZsYXRlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRoZSBuYW1lIG9mIHRoZSBwYWtvIGZ1bmN0aW9uIHRvIGNhbGwgOiBlaXRoZXIgXCJEZWZsYXRlXCIgb3IgXCJJbmZsYXRlXCIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiAoZGUpY29tcHJlc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIEZsYXRlV29ya2VyKGFjdGlvbiwgb3B0aW9ucykge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkZsYXRlV29ya2VyL1wiICsgYWN0aW9uKTtcblxuICAgIHRoaXMuX3Bha28gPSBudWxsO1xuICAgIHRoaXMuX3Bha29BY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy5fcGFrb09wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHRoZSBgbWV0YWAgb2JqZWN0IGZyb20gdGhlIGxhc3QgY2h1bmsgcmVjZWl2ZWRcbiAgICAvLyB0aGlzIGFsbG93IHRoaXMgd29ya2VyIHRvIHBhc3MgYXJvdW5kIG1ldGFkYXRhXG4gICAgdGhpcy5tZXRhID0ge307XG59XG5cbnV0aWxzLmluaGVyaXRzKEZsYXRlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLm1ldGEgPSBjaHVuay5tZXRhO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKHV0aWxzLnRyYW5zZm9ybVRvKEFSUkFZX1RZUEUsIGNodW5rLmRhdGEpLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaChbXSwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgX3Bha28gb2JqZWN0LlxuICogVE9ETzogbGF6eS1sb2FkaW5nIHRoaXMgb2JqZWN0IGlzbid0IHRoZSBiZXN0IHNvbHV0aW9uIGJ1dCBpdCdzIHRoZVxuICogcXVpY2tlc3QuIFRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIGxhenktbG9hZCB0aGUgd29ya2VyIGxpc3QuIFNlZSBhbHNvIHRoZVxuICogaXNzdWUgIzQ0Ni5cbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLl9jcmVhdGVQYWtvID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Bha28gPSBuZXcgcGFrb1t0aGlzLl9wYWtvQWN0aW9uXSh7XG4gICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgbGV2ZWw6IHRoaXMuX3Bha29PcHRpb25zLmxldmVsIHx8IC0xIC8vIGRlZmF1bHQgY29tcHJlc3Npb25cbiAgICB9KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcGFrby5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiBzZWxmLm1ldGFcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkRlZmxhdGVcIiwgY29tcHJlc3Npb25PcHRpb25zKTtcbn07XG5leHBvcnRzLnVuY29tcHJlc3NXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0ZVdvcmtlcihcIkluZmxhdGVcIiwge30pO1xufTtcbiJdLCJuYW1lcyI6WyJVU0VfVFlQRURBUlJBWSIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwicGFrbyIsInJlcXVpcmUiLCJ1dGlscyIsIkdlbmVyaWNXb3JrZXIiLCJBUlJBWV9UWVBFIiwiZXhwb3J0cyIsIm1hZ2ljIiwiRmxhdGVXb3JrZXIiLCJhY3Rpb24iLCJvcHRpb25zIiwiY2FsbCIsIl9wYWtvIiwiX3Bha29BY3Rpb24iLCJfcGFrb09wdGlvbnMiLCJtZXRhIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsIl9jcmVhdGVQYWtvIiwicHVzaCIsInRyYW5zZm9ybVRvIiwiZGF0YSIsImZsdXNoIiwiY2xlYW5VcCIsInJhdyIsImxldmVsIiwic2VsZiIsIm9uRGF0YSIsImNvbXByZXNzV29ya2VyIiwiY29tcHJlc3Npb25PcHRpb25zIiwidW5jb21wcmVzc1dvcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/flate.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!**************************************************************!*\
  !*** ../../node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utf8 = __webpack_require__(/*! ../utf8 */ \"(ssr)/../../node_modules/jszip/lib/utf8.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/../../node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ../signature */ \"(ssr)/../../node_modules/jszip/lib/signature.js\");\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */ var decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for(i = 0; i < bytes; i++){\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */ var generateUnixExternalFileAttr = function(unixPermissions, isDir) {\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */ var generateDosExternalFileAttr = function(dosPermissions) {\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */ var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo[\"file\"], compression = streamInfo[\"compression\"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo(\"string\", encodeFileName(comment)), utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = \"\", unicodePathExtraField = \"\", unicodeCommentExtraField = \"\", dir = file.dir, date = file.date;\n    var dataInfo = {\n        crc32: 0,\n        compressedSize: 0,\n        uncompressedSize: 0\n    };\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo[\"crc32\"];\n        dataInfo.compressedSize = streamInfo[\"compressedSize\"];\n        dataInfo.uncompressedSize = streamInfo[\"uncompressedSize\"];\n    }\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if (platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else {\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | date.getUTCMonth() + 1;\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField = // Version\n        decToHex(1, 1) + // NameCRC32\n        decToHex(crc32(encodedFileName), 4) + // UnicodeName\n        utfEncodedFileName;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"up\" + // size\n        decToHex(unicodePathExtraField.length, 2) + // content\n        unicodePathExtraField;\n    }\n    if (useUTF8ForComment) {\n        unicodeCommentExtraField = // Version\n        decToHex(1, 1) + // CommentCRC32\n        decToHex(crc32(encodedComment), 4) + // UnicodeName\n        utfEncodedComment;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"uc\" + // size\n        decToHex(unicodeCommentExtraField.length, 2) + // content\n        unicodeCommentExtraField;\n    }\n    var header = \"\";\n    // version needed to extract\n    header += \"\\n\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n    var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n    header + // file comment length\n    decToHex(encodedComment.length, 2) + // disk number start\n    \"\\x00\\x00\" + // internal file attributes TODO\n    \"\\x00\\x00\" + // external file attributes\n    decToHex(extFileAttr, 4) + // relative offset of local header\n    decToHex(offset, 4) + // file name\n    encodedFileName + // extra field\n    extraFields + // file comment\n    encodedComment;\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */ var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n    \"\\x00\\x00\" + // number of the disk with the start of the central directory\n    \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n    decToHex(entriesCount, 2) + // total number of entries in the central directory\n    decToHex(entriesCount, 2) + // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) + // .ZIP file comment length\n    decToHex(encodedComment.length, 2) + // .ZIP file comment\n    encodedComment;\n    return dirEnd;\n};\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */ var generateDataDescriptors = function(streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes\n    decToHex(streamInfo[\"crc32\"], 4) + // compressed size                 4 bytes\n    decToHex(streamInfo[\"compressedSize\"], 4) + // uncompressed size               4 bytes\n    decToHex(streamInfo[\"uncompressedSize\"], 4);\n    return descriptor;\n};\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */ function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n/**\n * @see GenericWorker.push\n */ ZipFileWorker.prototype.push = function(chunk) {\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n    if (this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n        GenericWorker.prototype.push.call(this, {\n            data: chunk.data,\n            meta: {\n                currentFile: this.currentFile,\n                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */ ZipFileWorker.prototype.openedSource = function(streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo[\"file\"].name;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    // don't stream folders (because they don't have any content)\n    if (streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */ ZipFileWorker.prototype.closedSource = function(streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n    this.dirRecords.push(record.dirRecord);\n    if (streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data: generateDataDescriptors(streamInfo),\n            meta: {\n                percent: 100\n            }\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n        while(this.contentBuffer.length){\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n/**\n * @see GenericWorker.flush\n */ ZipFileWorker.prototype.flush = function() {\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++){\n        this.push({\n            data: this.dirRecords[i],\n            meta: {\n                percent: 100\n            }\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n    this.push({\n        data: dirEnd,\n        meta: {\n            percent: 100\n        }\n    });\n};\n/**\n * Prepare the next source to be read.\n */ ZipFileWorker.prototype.prepareNextSource = function() {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n/**\n * @see GenericWorker.registerPrevious\n */ ZipFileWorker.prototype.registerPrevious = function(previous) {\n    this._sources.push(previous);\n    var self = this;\n    previous.on(\"data\", function(chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on(\"end\", function() {\n        self.closedSource(self.previous.streamInfo);\n        if (self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on(\"error\", function(e) {\n        self.error(e);\n    });\n    return this;\n};\n/**\n * @see GenericWorker.resume\n */ ZipFileWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n/**\n * @see GenericWorker.error\n */ ZipFileWorker.prototype.error = function(e) {\n    var sources = this._sources;\n    if (!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++){\n        try {\n            sources[i].error(e);\n        } catch (e) {\n        // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n/**\n * @see GenericWorker.lock\n */ ZipFileWorker.prototype.lock = function() {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++){\n        sources[i].lock();\n    }\n};\nmodule.exports = ZipFileWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9aaXBGaWxlV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywyRkFBeUI7QUFDckQsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUMsMkRBQVM7QUFDNUIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUksWUFBWUosbUJBQU9BLENBQUMscUVBQWM7QUFFdEM7Ozs7OztDQU1DLEdBQ0QsSUFBSUssV0FBVyxTQUFTQyxHQUFHLEVBQUVDLEtBQUs7SUFDOUIsSUFBSUMsTUFBTSxJQUFJQztJQUNkLElBQUtBLElBQUksR0FBR0EsSUFBSUYsT0FBT0UsSUFBSztRQUN4QkQsT0FBT0UsT0FBT0MsWUFBWSxDQUFDTCxNQUFNO1FBQ2pDQSxNQUFNQSxRQUFRO0lBQ2xCO0lBQ0EsT0FBT0U7QUFDWDtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsSUFBSUksK0JBQStCLFNBQVVDLGVBQWUsRUFBRUMsS0FBSztJQUUvRCxJQUFJQyxTQUFTRjtJQUNiLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2xCLDJEQUEyRDtRQUMzRCxvQkFBb0I7UUFDcEIsb0JBQW9CO1FBQ3BCRSxTQUFTRCxRQUFRLFNBQVM7SUFDOUI7SUFDQSxPQUFPLENBQUNDLFNBQVMsTUFBSyxLQUFNO0FBQ2hDO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsSUFBSUMsOEJBQThCLFNBQVVDLGNBQWM7SUFDdEQsZ0RBQWdEO0lBQ2hELE9BQU8sQ0FBQ0Esa0JBQWtCLEtBQU07QUFDcEM7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxJQUFJQyxtQkFBbUIsU0FBU0MsVUFBVSxFQUFFQyxlQUFlLEVBQUVDLGNBQWMsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGNBQWM7SUFDekcsSUFBSUMsT0FBT04s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QUFJcUMsVUFBVSxJQUFJLENBQUM1QixRQUFRO0lBQzNCLElBQUksSUFBSTNFLElBQUksR0FBR0EsSUFBSXVHLFFBQVEzRSxNQUFNLEVBQUU1QixJQUFLO1FBQ3BDdUcsT0FBTyxDQUFDdkcsRUFBRSxDQUFDd0csSUFBSTtJQUNuQjtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9aaXBGaWxlV29ya2VyLmpzPzVlZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi4vdXRmOFwiKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoXCIuLi9jcmMzMlwiKTtcbnZhciBzaWduYXR1cmUgPSByZXF1aXJlKFwiLi4vc2lnbmF0dXJlXCIpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gYSBzdHJpbmcgaW4gaGV4YWRlY2ltYWwuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlYyB0aGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbnZhciBkZWNUb0hleCA9IGZ1bmN0aW9uKGRlYywgYnl0ZXMpIHtcbiAgICB2YXIgaGV4ID0gXCJcIiwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgICBoZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMgJiAweGZmKTtcbiAgICAgICAgZGVjID0gZGVjID4+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgVU5JWCBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gdW5peFBlcm1pc3Npb25zIHRoZSB1bml4IHBlcm1pc3Npb25zIG9yIG51bGwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGlyIHRydWUgaWYgdGhlIGVudHJ5IGlzIGEgZGlyZWN0b3J5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGEgMzIgYml0IGludGVnZXIuXG4gKlxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNDcwNS90aGUtemlwLWZvcm1hdHMtZXh0ZXJuYWwtZmlsZS1hdHRyaWJ1dGUgOlxuICpcbiAqIFRUVFRzc3Ryd3hyd3hyd3gwMDAwMDAwMDAwQURWU0hSXG4gKiBeXl5eX19fX19fX19fX19fX19fX19fX19fX19fX19fXyBmaWxlIHR5cGUsIHNlZSB6aXBpbmZvLmMgKFVOWF8qKVxuICogICAgIF5eXl9fX19fX19fX19fX19fX19fX19fX19fX18gc2V0dWlkLCBzZXRnaWQsIHN0aWNreVxuICogICAgICAgIF5eXl5eXl5eXl9fX19fX19fX19fX19fX18gcGVybWlzc2lvbnNcbiAqICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eX19fX19fIG5vdCB1c2VkID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eIERPUyBhdHRyaWJ1dGUgYml0cyA6IEFyY2hpdmUsIERpcmVjdG9yeSwgVm9sdW1lIGxhYmVsLCBTeXN0ZW0gZmlsZSwgSGlkZGVuLCBSZWFkIG9ubHlcbiAqL1xudmFyIGdlbmVyYXRlVW5peEV4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAodW5peFBlcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IHVuaXhQZXJtaXNzaW9ucztcbiAgICBpZiAoIXVuaXhQZXJtaXNzaW9ucykge1xuICAgICAgICAvLyBJIGNhbid0IHVzZSBvY3RhbCB2YWx1ZXMgaW4gc3RyaWN0IG1vZGUsIGhlbmNlIHRoZSBoZXhhLlxuICAgICAgICAvLyAgMDQwNzc1ID0+IDB4NDFmZFxuICAgICAgICAvLyAwMTAwNjY0ID0+IDB4ODFiNFxuICAgICAgICByZXN1bHQgPSBpc0RpciA/IDB4NDFmZCA6IDB4ODFiNDtcbiAgICB9XG4gICAgcmV0dXJuIChyZXN1bHQgJiAweEZGRkYpIDw8IDE2O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRE9TIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkb3NQZXJtaXNzaW9ucyB0aGUgZG9zIHBlcm1pc3Npb25zIG9yIG51bGwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGlyIHRydWUgaWYgdGhlIGVudHJ5IGlzIGEgZGlyZWN0b3J5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGEgMzIgYml0IGludGVnZXIuXG4gKlxuICogQml0IDAgICAgIFJlYWQtT25seVxuICogQml0IDEgICAgIEhpZGRlblxuICogQml0IDIgICAgIFN5c3RlbVxuICogQml0IDMgICAgIFZvbHVtZSBMYWJlbFxuICogQml0IDQgICAgIERpcmVjdG9yeVxuICogQml0IDUgICAgIEFyY2hpdmVcbiAqL1xudmFyIGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uIChkb3NQZXJtaXNzaW9ucykge1xuICAgIC8vIHRoZSBkaXIgZmxhZyBpcyBhbHJlYWR5IHNldCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIHJldHVybiAoZG9zUGVybWlzc2lvbnMgfHwgMCkgICYgMHgzRjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIHZhcmlvdXMgcGFydHMgdXNlZCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBmaW5hbCB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtZWRDb250ZW50IGlzIHRoZSBjb250ZW50IHN0cmVhbWVkID9cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtaW5nRW5kZWQgaXMgdGhlIHN0cmVhbSBmaW5pc2hlZCA/XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBjdXJyZW50IG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gbGV0J3MgcHJldGVuZCB3ZSBhcmUgdGhpcyBwbGF0Zm9ybSAoY2hhbmdlIHBsYXRmb3JtIGRlcGVuZGVudHMgZmllbGRzKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgZmlsZSBuYW1lIC8gY29tbWVudC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHppcCBwYXJ0cy5cbiAqL1xudmFyIGdlbmVyYXRlWmlwUGFydHMgPSBmdW5jdGlvbihzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHN0cmVhbWluZ0VuZGVkLCBvZmZzZXQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIHZhciBmaWxlID0gc3RyZWFtSW5mb1tcImZpbGVcIl0sXG4gICAgICAgIGNvbXByZXNzaW9uID0gc3RyZWFtSW5mb1tcImNvbXByZXNzaW9uXCJdLFxuICAgICAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGZpbGUubmFtZSkpLFxuICAgICAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQsXG4gICAgICAgIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpLFxuICAgICAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgICAgIHVzZVVURjhGb3JGaWxlTmFtZSA9IHV0ZkVuY29kZWRGaWxlTmFtZS5sZW5ndGggIT09IGZpbGUubmFtZS5sZW5ndGgsXG4gICAgICAgIHVzZVVURjhGb3JDb21tZW50ID0gdXRmRW5jb2RlZENvbW1lbnQubGVuZ3RoICE9PSBjb21tZW50Lmxlbmd0aCxcbiAgICAgICAgZG9zVGltZSxcbiAgICAgICAgZG9zRGF0ZSxcbiAgICAgICAgZXh0cmFGaWVsZHMgPSBcIlwiLFxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPSBcIlwiLFxuICAgICAgICBkaXIgPSBmaWxlLmRpcixcbiAgICAgICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvW1wiY3JjMzJcIl07XG4gICAgICAgIGRhdGFJbmZvLmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1tcImNvbXByZXNzZWRTaXplXCJdO1xuICAgICAgICBkYXRhSW5mby51bmNvbXByZXNzZWRTaXplID0gc3RyZWFtSW5mb1tcInVuY29tcHJlc3NlZFNpemVcIl07XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvblxuICogb24gdGhlIGZpbGUgZW50cnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkYXRhIGRlc2NyaXB0b3JzLlxuICovXG52YXIgZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gXCJcIjtcbiAgICBkZXNjcmlwdG9yID0gc2lnbmF0dXJlLkRBVEFfREVTQ1JJUFRPUiArXG4gICAgICAgIC8vIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvW1wiY3JjMzJcIl0sIDQpICtcbiAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bXCJjb21wcmVzc2VkU2l6ZVwiXSwgNCkgK1xuICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1tcInVuY29tcHJlc3NlZFNpemVcIl0sIDQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cbi8qKlxuICogQSB3b3JrZXIgdG8gY29uY2F0ZW5hdGUgb3RoZXIgd29ya2VycyB0byBjcmVhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtRmlsZXMgYHRydWVgIHRvIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMsXG4gKiBgZmFsc2VgIHRvIGFjY3VtdWxhdGUgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gdGhlIHBsYXRmb3JtIHRvIHVzZSwgXCJVTklYXCIgb3IgXCJET1NcIi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gKi9cbmZ1bmN0aW9uIFppcEZpbGVXb3JrZXIoc3RyZWFtRmlsZXMsIGNvbW1lbnQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIlppcEZpbGVXb3JrZXJcIik7XG4gICAgLy8gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHNvIGZhci4gVGhpcyBkb2Vzbid0IGNvdW50IGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgLy8gVGhlIGNvbW1lbnQgb2YgdGhlIHppcCBmaWxlXG4gICAgdGhpcy56aXBDb21tZW50ID0gY29tbWVudDtcbiAgICAvLyBUaGUgcGxhdGZvcm0gXCJnZW5lcmF0aW5nXCIgdGhlIHppcCBmaWxlLlxuICAgIHRoaXMuemlwUGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAvLyB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICAgIHRoaXMuZW5jb2RlRmlsZU5hbWUgPSBlbmNvZGVGaWxlTmFtZTtcbiAgICAvLyBTaG91bGQgd2Ugc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyA/XG4gICAgdGhpcy5zdHJlYW1GaWxlcyA9IHN0cmVhbUZpbGVzO1xuICAgIC8vIElmIGBzdHJlYW1GaWxlc2AgaXMgZmFsc2UsIHdlIHdpbGwgbmVlZCB0byBhY2N1bXVsYXRlIHRoZSBjb250ZW50IG9mIHRoZVxuICAgIC8vIGZpbGVzIHRvIGNhbGN1bGF0ZSBzaXplcyAvIGNyYzMyIChhbmQgd3JpdGUgdGhlbSAqYmVmb3JlKiB0aGUgY29udGVudCkuXG4gICAgLy8gVGhpcyBib29sZWFuIGluZGljYXRlcyBpZiB3ZSBhcmUgYWNjdW11bGF0aW5nIGNodW5rcyAoaXQgd2lsbCBjaGFuZ2UgYSBsb3RcbiAgICAvLyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoaXMgd29ya2VyKS5cbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICAvLyBUaGUgYnVmZmVyIHJlY2VpdmluZyBjaHVua3Mgd2hlbiBhY2N1bXVsYXRpbmcgY29udGVudC5cbiAgICB0aGlzLmNvbnRlbnRCdWZmZXIgPSBbXTtcbiAgICAvLyBUaGUgbGlzdCBvZiBnZW5lcmF0ZWQgZGlyZWN0b3J5IHJlY29yZHMuXG4gICAgdGhpcy5kaXJSZWNvcmRzID0gW107XG4gICAgLy8gVGhlIG9mZnNldCAoaW4gYnl0ZXMpIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgemlwIGZpbGUgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSAwO1xuICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHppcCBmaWxlLlxuICAgIHRoaXMuZW50cmllc0NvdW50ID0gMDtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgYWRkZWQsIG51bGwgd2hlbiBoYW5kbGluZyB0aGUgZW5kIG9mIHRoZSB6aXAgZmlsZS5cbiAgICAvLyBVc2VkIGZvciB0aGUgZW1pdHRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1tcImZpbGVcIl0ubmFtZTtcblxuICAgIHZhciBzdHJlYW1lZENvbnRlbnQgPSB0aGlzLnN0cmVhbUZpbGVzICYmICFzdHJlYW1JbmZvW1wiZmlsZVwiXS5kaXI7XG5cbiAgICAvLyBkb24ndCBzdHJlYW0gZm9sZGVycyAoYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgYW55IGNvbnRlbnQpXG4gICAgaWYoc3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogcmVjb3JkLmZpbGVSZWNvcmQsXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgd2hvbGUgZmlsZSBiZWZvcmUgcHVzaGluZyBhbnl0aGluZ1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBmaW5pc2hlZCBhIHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBmaW5pc2hlZCBzb3VyY2UuXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmNsb3NlZFNvdXJjZSA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7XG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bXCJmaWxlXCJdLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmNsb3NlZFNvdXJjZShzZWxmLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgICAgICBpZihzZWxmLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJHZW5lcmljV29ya2VyIiwidXRmOCIsImNyYzMyIiwic2lnbmF0dXJlIiwiZGVjVG9IZXgiLCJkZWMiLCJieXRlcyIsImhleCIsImkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyIiwidW5peFBlcm1pc3Npb25zIiwiaXNEaXIiLCJyZXN1bHQiLCJnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIiLCJkb3NQZXJtaXNzaW9ucyIsImdlbmVyYXRlWmlwUGFydHMiLCJzdHJlYW1JbmZvIiwic3RyZWFtZWRDb250ZW50Iiwic3RyZWFtaW5nRW5kZWQiLCJvZmZzZXQiLCJwbGF0Zm9ybSIsImVuY29kZUZpbGVOYW1lIiwiZmlsZSIsImNvbXByZXNzaW9uIiwidXNlQ3VzdG9tRW5jb2RpbmciLCJ1dGY4ZW5jb2RlIiwiZW5jb2RlZEZpbGVOYW1lIiwidHJhbnNmb3JtVG8iLCJuYW1lIiwidXRmRW5jb2RlZEZpbGVOYW1lIiwiY29tbWVudCIsImVuY29kZWRDb21tZW50IiwidXRmRW5jb2RlZENvbW1lbnQiLCJ1c2VVVEY4Rm9yRmlsZU5hbWUiLCJsZW5ndGgiLCJ1c2VVVEY4Rm9yQ29tbWVudCIsImRvc1RpbWUiLCJkb3NEYXRlIiwiZXh0cmFGaWVsZHMiLCJ1bmljb2RlUGF0aEV4dHJhRmllbGQiLCJ1bmljb2RlQ29tbWVudEV4dHJhRmllbGQiLCJkaXIiLCJkYXRlIiwiZGF0YUluZm8iLCJjb21wcmVzc2VkU2l6ZSIsInVuY29tcHJlc3NlZFNpemUiLCJiaXRmbGFnIiwiZXh0RmlsZUF0dHIiLCJ2ZXJzaW9uTWFkZUJ5IiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiaGVhZGVyIiwibWFnaWMiLCJmaWxlUmVjb3JkIiwiTE9DQUxfRklMRV9IRUFERVIiLCJkaXJSZWNvcmQiLCJDRU5UUkFMX0ZJTEVfSEVBREVSIiwiZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kIiwiZW50cmllc0NvdW50IiwiY2VudHJhbERpckxlbmd0aCIsImxvY2FsRGlyTGVuZ3RoIiwiZGlyRW5kIiwiQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwiREFUQV9ERVNDUklQVE9SIiwiWmlwRmlsZVdvcmtlciIsInN0cmVhbUZpbGVzIiwiY2FsbCIsImJ5dGVzV3JpdHRlbiIsInppcENvbW1lbnQiLCJ6aXBQbGF0Zm9ybSIsImFjY3VtdWxhdGUiLCJjb250ZW50QnVmZmVyIiwiZGlyUmVjb3JkcyIsImN1cnJlbnRTb3VyY2VPZmZzZXQiLCJjdXJyZW50RmlsZSIsIl9zb3VyY2VzIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwdXNoIiwiY2h1bmsiLCJjdXJyZW50RmlsZVBlcmNlbnQiLCJtZXRhIiwicGVyY2VudCIsInJlbWFpbmluZ0ZpbGVzIiwiZGF0YSIsIm9wZW5lZFNvdXJjZSIsInJlY29yZCIsImNsb3NlZFNvdXJjZSIsInNoaWZ0IiwiZmx1c2giLCJwcmVwYXJlTmV4dFNvdXJjZSIsInByZXZpb3VzIiwiaXNQYXVzZWQiLCJwYXVzZSIsInJlc3VtZSIsInJlZ2lzdGVyUHJldmlvdXMiLCJzZWxmIiwib24iLCJwcm9jZXNzQ2h1bmsiLCJlbmQiLCJlIiwiZXJyb3IiLCJnZW5lcmF0ZWRFcnJvciIsInNvdXJjZXMiLCJsb2NrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/generate/ZipFileWorker.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/generate/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/jszip/lib/generate/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar compressions = __webpack_require__(/*! ../compressions */ \"(ssr)/../../node_modules/jszip/lib/compressions.js\");\nvar ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ \"(ssr)/../../node_modules/jszip/lib/generate/ZipFileWorker.js\");\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */ var getCompression = function(fileCompression, zipCompression) {\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */ exports.generateWorker = function(zip, options, comment) {\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n        zip.forEach(function(relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n            file._compressWorker(compression, compressionOptions).withStreamInfo(\"file\", {\n                name: relativePath,\n                dir: dir,\n                date: date,\n                comment: file.comment || \"\",\n                unixPermissions: file.unixPermissions,\n                dosPermissions: file.dosPermissions\n            }).pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n    return zipFileWorker;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUM1QyxJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHFGQUFpQjtBQUU3Qzs7Ozs7Q0FLQyxHQUNELElBQUlFLGlCQUFpQixTQUFVQyxlQUFlLEVBQUVDLGNBQWM7SUFFMUQsSUFBSUMsa0JBQWtCRixtQkFBbUJDO0lBQ3pDLElBQUlFLGNBQWNQLFlBQVksQ0FBQ00sZ0JBQWdCO0lBQy9DLElBQUksQ0FBQ0MsYUFBYTtRQUNkLE1BQU0sSUFBSUMsTUFBTUYsa0JBQWtCO0lBQ3RDO0lBQ0EsT0FBT0M7QUFDWDtBQUVBOzs7OztDQUtDLEdBQ0RFLHNCQUFzQixHQUFHLFNBQVVFLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBRXBELElBQUlDLGdCQUFnQixJQUFJWixjQUFjVSxRQUFRRyxXQUFXLEVBQUVGLFNBQVNELFFBQVFJLFFBQVEsRUFBRUosUUFBUUssY0FBYztJQUM1RyxJQUFJQyxlQUFlO0lBQ25CLElBQUk7UUFFQVAsSUFBSVEsT0FBTyxDQUFDLFNBQVVDLFlBQVksRUFBRUMsSUFBSTtZQUNwQ0g7WUFDQSxJQUFJWCxjQUFjSixlQUFla0IsS0FBS1QsT0FBTyxDQUFDTCxXQUFXLEVBQUVLLFFBQVFMLFdBQVc7WUFDOUUsSUFBSWUscUJBQXFCRCxLQUFLVCxPQUFPLENBQUNVLGtCQUFrQixJQUFJVixRQUFRVSxrQkFBa0IsSUFBSSxDQUFDO1lBQzNGLElBQUlDLE1BQU1GLEtBQUtFLEdBQUcsRUFBRUMsT0FBT0gsS0FBS0csSUFBSTtZQUVwQ0gsS0FBS0ksZUFBZSxDQUFDbEIsYUFBYWUsb0JBQzdCSSxjQUFjLENBQUMsUUFBUTtnQkFDcEJDLE1BQU9QO2dCQUNQRyxLQUFNQTtnQkFDTkMsTUFBT0E7Z0JBQ1BYLFNBQVVRLEtBQUtSLE9BQU8sSUFBSTtnQkFDMUJlLGlCQUFrQlAsS0FBS08sZUFBZTtnQkFDdENDLGdCQUFpQlIsS0FBS1EsY0FBYztZQUN4QyxHQUNDQyxJQUFJLENBQUNoQjtRQUNkO1FBQ0FBLGNBQWNJLFlBQVksR0FBR0E7SUFDakMsRUFBRSxPQUFPYSxHQUFHO1FBQ1JqQixjQUFja0IsS0FBSyxDQUFDRDtJQUN4QjtJQUVBLE9BQU9qQjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9nZW5lcmF0ZS9pbmRleC5qcz8zZTljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZShcIi4uL2NvbXByZXNzaW9uc1wiKTtcbnZhciBaaXBGaWxlV29ya2VyID0gcmVxdWlyZShcIi4vWmlwRmlsZVdvcmtlclwiKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJmaWxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA6IHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgICAgICBkYXRlIDogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA6IGZpbGUuY29tbWVudCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBmaWxlLmRvc1Blcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iXSwibmFtZXMiOlsiY29tcHJlc3Npb25zIiwicmVxdWlyZSIsIlppcEZpbGVXb3JrZXIiLCJnZXRDb21wcmVzc2lvbiIsImZpbGVDb21wcmVzc2lvbiIsInppcENvbXByZXNzaW9uIiwiY29tcHJlc3Npb25OYW1lIiwiY29tcHJlc3Npb24iLCJFcnJvciIsImV4cG9ydHMiLCJnZW5lcmF0ZVdvcmtlciIsInppcCIsIm9wdGlvbnMiLCJjb21tZW50IiwiemlwRmlsZVdvcmtlciIsInN0cmVhbUZpbGVzIiwicGxhdGZvcm0iLCJlbmNvZGVGaWxlTmFtZSIsImVudHJpZXNDb3VudCIsImZvckVhY2giLCJyZWxhdGl2ZVBhdGgiLCJmaWxlIiwiY29tcHJlc3Npb25PcHRpb25zIiwiZGlyIiwiZGF0ZSIsIl9jb21wcmVzc1dvcmtlciIsIndpdGhTdHJlYW1JbmZvIiwibmFtZSIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwicGlwZSIsImUiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/generate/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/jszip/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Representation a of zip file in js\n * @constructor\n */ function JSZip() {\n    // if this constructor is used without `new`, it adds `new` before itself:\n    if (!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n    if (arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    // NOTE: we use a null prototype because we do not\n    // want filenames like \"toString\" coming from a zip file\n    // to overwrite methods and attributes in a normal Object.\n    this.files = Object.create(null);\n    this.comment = null;\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for(var i in this){\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"(ssr)/../../node_modules/jszip/lib/object.js\");\nJSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ \"(ssr)/../../node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/../../node_modules/jszip/lib/defaults.js\");\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.10.1\";\nJSZip.loadAsync = function(content, options) {\n    return new JSZip().loadAsync(content, options);\n};\nJSZip.external = __webpack_require__(/*! ./external */ \"(ssr)/../../node_modules/jszip/lib/external.js\");\nmodule.exports = JSZip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Q0FHQyxHQUNELFNBQVNBO0lBQ0wsMEVBQTBFO0lBQzFFLElBQUcsQ0FBRSxLQUFJLFlBQVlBLEtBQUksR0FBSTtRQUN6QixPQUFPLElBQUlBO0lBQ2Y7SUFFQSxJQUFHQyxVQUFVQyxNQUFNLEVBQUU7UUFDakIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBRUEsZ0NBQWdDO0lBQ2hDLElBQUk7SUFDSix1QkFBdUI7SUFDdkIsOEJBQThCO0lBQzlCLElBQUk7SUFDSixrREFBa0Q7SUFDbEQsd0RBQXdEO0lBQ3hELDBEQUEwRDtJQUMxRCxJQUFJLENBQUNDLEtBQUssR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBRTNCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBRWYsZ0NBQWdDO0lBQ2hDLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDVCxJQUFJQyxTQUFTLElBQUlWO1FBQ2pCLElBQUssSUFBSVcsS0FBSyxJQUFJLENBQUU7WUFDaEIsSUFBSSxPQUFPLElBQUksQ0FBQ0EsRUFBRSxLQUFLLFlBQVk7Z0JBQy9CRCxNQUFNLENBQUNDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEVBQUU7WUFDdkI7UUFDSjtRQUNBLE9BQU9EO0lBQ1g7QUFDSjtBQUNBVixNQUFNWSxTQUFTLEdBQUdDLG1CQUFPQSxDQUFDLDhEQUFVO0FBQ3BDYixNQUFNWSxTQUFTLENBQUNFLFNBQVMsR0FBR0QsbUJBQU9BLENBQUMsMERBQVE7QUFDNUNiLE1BQU1lLE9BQU8sR0FBR0YsbUJBQU9BLENBQUMsZ0VBQVc7QUFDbkNiLE1BQU1nQixRQUFRLEdBQUdILG1CQUFPQSxDQUFDLGtFQUFZO0FBRXJDLGlEQUFpRDtBQUNqRCx3RUFBd0U7QUFDeEViLE1BQU1pQixPQUFPLEdBQUc7QUFFaEJqQixNQUFNYyxTQUFTLEdBQUcsU0FBVUksT0FBTyxFQUFFQyxPQUFPO0lBQ3hDLE9BQU8sSUFBSW5CLFFBQVFjLFNBQVMsQ0FBQ0ksU0FBU0M7QUFDMUM7QUFFQW5CLE1BQU1vQixRQUFRLEdBQUdQLG1CQUFPQSxDQUFDLGtFQUFZO0FBQ3JDUSxPQUFPQyxPQUFPLEdBQUd0QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvaW5kZXguanM/MWYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBhIG9mIHppcCBmaWxlIGluIGpzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSlNaaXAoKSB7XG4gICAgLy8gaWYgdGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHdpdGhvdXQgYG5ld2AsIGl0IGFkZHMgYG5ld2AgYmVmb3JlIGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU1ppcCgpO1xuICAgIH1cblxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgLy8gTk9URTogd2UgdXNlIGEgbnVsbCBwcm90b3R5cGUgYmVjYXVzZSB3ZSBkbyBub3RcbiAgICAvLyB3YW50IGZpbGVuYW1lcyBsaWtlIFwidG9TdHJpbmdcIiBjb21pbmcgZnJvbSBhIHppcCBmaWxlXG4gICAgLy8gdG8gb3ZlcndyaXRlIG1ldGhvZHMgYW5kIGF0dHJpYnV0ZXMgaW4gYSBub3JtYWwgT2JqZWN0LlxuICAgIHRoaXMuZmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXdPYmogPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IHRoaXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9O1xufVxuSlNaaXAucHJvdG90eXBlID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoXCIuL2xvYWRcIik7XG5KU1ppcC5zdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy4xMC4xXCI7XG5cbkpTWmlwLmxvYWRBc3luYyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBKU1ppcCgpLmxvYWRBc3luYyhjb250ZW50LCBvcHRpb25zKTtcbn07XG5cbkpTWmlwLmV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEpTWmlwO1xuIl0sIm5hbWVzIjpbIkpTWmlwIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiRXJyb3IiLCJmaWxlcyIsIk9iamVjdCIsImNyZWF0ZSIsImNvbW1lbnQiLCJyb290IiwiY2xvbmUiLCJuZXdPYmoiLCJpIiwicHJvdG90eXBlIiwicmVxdWlyZSIsImxvYWRBc3luYyIsInN1cHBvcnQiLCJkZWZhdWx0cyIsInZlcnNpb24iLCJjb250ZW50Iiwib3B0aW9ucyIsImV4dGVybmFsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/load.js":
/*!********************************************!*\
  !*** ../../node_modules/jszip/lib/load.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/../../node_modules/jszip/lib/external.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/../../node_modules/jszip/lib/utf8.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"(ssr)/../../node_modules/jszip/lib/zipEntries.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/../../node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/../../node_modules/jszip/lib/nodejsUtils.js\");\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */ function checkEntryCRC32(zipEntry) {\n    return new external.Promise(function(resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function(e) {\n            reject(e);\n        }).on(\"end\", function() {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        }).resume();\n    });\n}\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64).then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [\n            external.Promise.resolve(zipEntries)\n        ];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for(var i = 0; i < files.length; i++){\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for(var i = 0; i < files.length; i++){\n            var input = files[i];\n            var unsafeName = input.fileNameStr;\n            var safeName = utils.resolve(input.fileNameStr);\n            zip.file(safeName, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions: input.unixPermissions,\n                dosPermissions: input.dosPermissions,\n                createFolders: options.createFolders\n            });\n            if (!input.dir) {\n                zip.file(safeName).unsafeOriginalName = unsafeName;\n            }\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n        return zip;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNERBQVM7QUFDN0IsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUMsa0VBQVk7QUFDbkMsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUMsMERBQVE7QUFDM0IsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUMsc0VBQWM7QUFDdkMsSUFBSUksYUFBYUosbUJBQU9BLENBQUMsb0ZBQXFCO0FBQzlDLElBQUlLLGNBQWNMLG1CQUFPQSxDQUFDLHdFQUFlO0FBRXpDOzs7O0NBSUMsR0FDRCxTQUFTTSxnQkFBZ0JDLFFBQVE7SUFDN0IsT0FBTyxJQUFJTixTQUFTTyxPQUFPLENBQUMsU0FBVUMsT0FBTyxFQUFFQyxNQUFNO1FBQ2pELElBQUlDLFNBQVNKLFNBQVNLLFlBQVksQ0FBQ0MsZ0JBQWdCLEdBQUdDLElBQUksQ0FBQyxJQUFJVjtRQUMvRE8sT0FBT0ksRUFBRSxDQUFDLFNBQVMsU0FBVUMsQ0FBQztZQUMxQk4sT0FBT007UUFDWCxHQUNLRCxFQUFFLENBQUMsT0FBTztZQUNQLElBQUlKLE9BQU9NLFVBQVUsQ0FBQ0MsS0FBSyxLQUFLWCxTQUFTSyxZQUFZLENBQUNNLEtBQUssRUFBRTtnQkFDekRSLE9BQU8sSUFBSVMsTUFBTTtZQUNyQixPQUFPO2dCQUNIVjtZQUNKO1FBQ0osR0FDQ1csTUFBTTtJQUNmO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHLFNBQVVDLElBQUksRUFBRUMsT0FBTztJQUNwQyxJQUFJQyxNQUFNLElBQUk7SUFDZEQsVUFBVXpCLE1BQU0yQixNQUFNLENBQUNGLFdBQVcsQ0FBQyxHQUFHO1FBQ2xDRyxRQUFRO1FBQ1JDLFlBQVk7UUFDWkMsdUJBQXVCO1FBQ3ZCQyxlQUFlO1FBQ2ZDLGdCQUFnQjdCLEtBQUs4QixVQUFVO0lBQ25DO0lBRUEsSUFBSTNCLFlBQVk0QixNQUFNLElBQUk1QixZQUFZNkIsUUFBUSxDQUFDWCxPQUFPO1FBQ2xELE9BQU90QixTQUFTTyxPQUFPLENBQUNFLE1BQU0sQ0FBQyxJQUFJUyxNQUFNO0lBQzdDO0lBRUEsT0FBT3BCLE1BQU1vQyxjQUFjLENBQUMsdUJBQXVCWixNQUFNLE1BQU1DLFFBQVFLLHFCQUFxQixFQUFFTCxRQUFRRyxNQUFNLEVBQ3ZHUyxJQUFJLENBQUMsU0FBVWIsSUFBSTtRQUNoQixJQUFJYyxhQUFhLElBQUlsQyxXQUFXcUI7UUFDaENhLFdBQVdDLElBQUksQ0FBQ2Y7UUFDaEIsT0FBT2M7SUFDWCxHQUFHRCxJQUFJLENBQUMsU0FBU1IsV0FBV1MsVUFBVTtRQUNsQyxJQUFJRSxXQUFXO1lBQUN0QyxTQUFTTyxPQUFPLENBQUNDLE9BQU8sQ0FBQzRCO1NBQVk7UUFDckQsSUFBSUcsUUFBUUgsV0FBV0csS0FBSztRQUM1QixJQUFJaEIsUUFBUUksVUFBVSxFQUFFO1lBQ3BCLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUVELElBQUs7Z0JBQ25DRixTQUFTSSxJQUFJLENBQUNyQyxnQkFBZ0JrQyxLQUFLLENBQUNDLEVBQUU7WUFDMUM7UUFDSjtRQUNBLE9BQU94QyxTQUFTTyxPQUFPLENBQUNvQyxHQUFHLENBQUNMO0lBQ2hDLEdBQUdILElBQUksQ0FBQyxTQUFTUyxTQUFTQyxPQUFPO1FBQzdCLElBQUlULGFBQWFTLFFBQVFDLEtBQUs7UUFDOUIsSUFBSVAsUUFBUUgsV0FBV0csS0FBSztRQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1lBQ25DLElBQUlPLFFBQVFSLEtBQUssQ0FBQ0MsRUFBRTtZQUVwQixJQUFJUSxhQUFhRCxNQUFNRSxXQUFXO1lBQ2xDLElBQUlDLFdBQVdwRCxNQUFNVSxPQUFPLENBQUN1QyxNQUFNRSxXQUFXO1lBRTlDekIsSUFBSTJCLElBQUksQ0FBQ0QsVUFBVUgsTUFBTXBDLFlBQVksRUFBRTtnQkFDbkN5QyxRQUFRO2dCQUNSeEIsdUJBQXVCO2dCQUN2QnlCLE1BQU1OLE1BQU1NLElBQUk7Z0JBQ2hCQyxLQUFLUCxNQUFNTyxHQUFHO2dCQUNkQyxTQUFTUixNQUFNUyxjQUFjLENBQUNmLE1BQU0sR0FBR00sTUFBTVMsY0FBYyxHQUFHO2dCQUM5REMsaUJBQWlCVixNQUFNVSxlQUFlO2dCQUN0Q0MsZ0JBQWdCWCxNQUFNVyxjQUFjO2dCQUNwQzdCLGVBQWVOLFFBQVFNLGFBQWE7WUFDeEM7WUFDQSxJQUFJLENBQUNrQixNQUFNTyxHQUFHLEVBQUU7Z0JBQ1o5QixJQUFJMkIsSUFBSSxDQUFDRCxVQUFVUyxrQkFBa0IsR0FBR1g7WUFDNUM7UUFDSjtRQUNBLElBQUlaLFdBQVd3QixVQUFVLENBQUNuQixNQUFNLEVBQUU7WUFDOUJqQixJQUFJK0IsT0FBTyxHQUFHbkIsV0FBV3dCLFVBQVU7UUFDdkM7UUFFQSxPQUFPcEM7SUFDWDtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzPzEyMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi91dGY4XCIpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKFwiLi96aXBFbnRyaWVzXCIpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKFwiLi9zdHJlYW0vQ3JjMzJQcm9iZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xuXG4vKipcbiAqIENoZWNrIHRoZSBDUkMzMiBvZiBhbiBlbnRyeS5cbiAqIEBwYXJhbSB7WmlwRW50cnl9IHppcEVudHJ5IHRoZSB6aXAgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtQcm9taXNlfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBjaGVja0VudHJ5Q1JDMzIoemlwRW50cnkpIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgd29ya2VyID0gemlwRW50cnkuZGVjb21wcmVzc2VkLmdldENvbnRlbnRXb3JrZXIoKS5waXBlKG5ldyBDcmMzMlByb2JlKCkpO1xuICAgICAgICB3b3JrZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2VyLnN0cmVhbUluZm8uY3JjMzIgIT09IHppcEVudHJ5LmRlY29tcHJlc3NlZC5jcmMzMikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IENSQzMyIG1pc21hdGNoXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN1bWUoKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciB6aXAgPSB0aGlzO1xuICAgIG9wdGlvbnMgPSB1dGlscy5leHRlbmQob3B0aW9ucyB8fCB7fSwge1xuICAgICAgICBiYXNlNjQ6IGZhbHNlLFxuICAgICAgICBjaGVja0NSQzMyOiBmYWxzZSxcbiAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlRm9sZGVyczogZmFsc2UsXG4gICAgICAgIGRlY29kZUZpbGVOYW1lOiB1dGY4LnV0ZjhkZWNvZGVcbiAgICB9KTtcblxuICAgIGlmIChub2RlanNVdGlscy5pc05vZGUgJiYgbm9kZWpzVXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkpTWmlwIGNhbid0IGFjY2VwdCBhIHN0cmVhbSB3aGVuIGxvYWRpbmcgYSB6aXAgZmlsZS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5wcmVwYXJlQ29udGVudChcInRoZSBsb2FkZWQgemlwIGZpbGVcIiwgZGF0YSwgdHJ1ZSwgb3B0aW9ucy5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG9wdGlvbnMuYmFzZTY0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHppcEVudHJpZXMgPSBuZXcgWmlwRW50cmllcyhvcHRpb25zKTtcbiAgICAgICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB6aXBFbnRyaWVzO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIGNoZWNrQ1JDMzIoemlwRW50cmllcykge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hlY2tDUkMzMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGVja0VudHJ5Q1JDMzIoZmlsZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIGFkZEZpbGVzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciB1bnNhZmVOYW1lID0gaW5wdXQuZmlsZU5hbWVTdHI7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVOYW1lID0gdXRpbHMucmVzb2x2ZShpbnB1dC5maWxlTmFtZVN0cik7XG5cbiAgICAgICAgICAgICAgICB6aXAuZmlsZShzYWZlTmFtZSwgaW5wdXQuZGVjb21wcmVzc2VkLCB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRlOiBpbnB1dC5kYXRlLFxuICAgICAgICAgICAgICAgICAgICBkaXI6IGlucHV0LmRpcixcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudDogaW5wdXQuZmlsZUNvbW1lbnRTdHIubGVuZ3RoID8gaW5wdXQuZmlsZUNvbW1lbnRTdHIgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnM6IGlucHV0LnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnM6IGlucHV0LmRvc1Blcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRpcikge1xuICAgICAgICAgICAgICAgICAgICB6aXAuZmlsZShzYWZlTmFtZSkudW5zYWZlT3JpZ2luYWxOYW1lID0gdW5zYWZlTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHppcC5jb21tZW50ID0gemlwRW50cmllcy56aXBDb21tZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gemlwO1xuICAgICAgICB9KTtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiZXh0ZXJuYWwiLCJ1dGY4IiwiWmlwRW50cmllcyIsIkNyYzMyUHJvYmUiLCJub2RlanNVdGlscyIsImNoZWNrRW50cnlDUkMzMiIsInppcEVudHJ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3b3JrZXIiLCJkZWNvbXByZXNzZWQiLCJnZXRDb250ZW50V29ya2VyIiwicGlwZSIsIm9uIiwiZSIsInN0cmVhbUluZm8iLCJjcmMzMiIsIkVycm9yIiwicmVzdW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsImRhdGEiLCJvcHRpb25zIiwiemlwIiwiZXh0ZW5kIiwiYmFzZTY0IiwiY2hlY2tDUkMzMiIsIm9wdGltaXplZEJpbmFyeVN0cmluZyIsImNyZWF0ZUZvbGRlcnMiLCJkZWNvZGVGaWxlTmFtZSIsInV0ZjhkZWNvZGUiLCJpc05vZGUiLCJpc1N0cmVhbSIsInByZXBhcmVDb250ZW50IiwidGhlbiIsInppcEVudHJpZXMiLCJsb2FkIiwicHJvbWlzZXMiLCJmaWxlcyIsImkiLCJsZW5ndGgiLCJwdXNoIiwiYWxsIiwiYWRkRmlsZXMiLCJyZXN1bHRzIiwic2hpZnQiLCJpbnB1dCIsInVuc2FmZU5hbWUiLCJmaWxlTmFtZVN0ciIsInNhZmVOYW1lIiwiZmlsZSIsImJpbmFyeSIsImRhdGUiLCJkaXIiLCJjb21tZW50IiwiZmlsZUNvbW1lbnRTdHIiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyIsInVuc2FmZU9yaWdpbmFsTmFtZSIsInppcENvbW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/load.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/nodejsUtils.js":
/*!***************************************************!*\
  !*** ../../node_modules/jszip/lib/nodejsUtils.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */ isNode: typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */ newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error('The \"data\" argument must not be a number');\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */ allocBuffer: function(size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */ isBuffer: function(b) {\n        return Buffer.isBuffer(b);\n    },\n    isStream: function(obj) {\n        return obj && typeof obj.on === \"function\" && typeof obj.pause === \"function\" && typeof obj.resume === \"function\";\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSxPQUFPQyxPQUFPLEdBQUc7SUFDYjs7OztLQUlDLEdBQ0RDLFFBQVMsT0FBT0MsV0FBVztJQUMzQjs7Ozs7S0FLQyxHQUNEQyxlQUFlLFNBQVNDLElBQUksRUFBRUMsUUFBUTtRQUNsQyxJQUFJSCxPQUFPSSxJQUFJLElBQUlKLE9BQU9JLElBQUksS0FBS0MsV0FBV0QsSUFBSSxFQUFFO1lBQ2hELE9BQU9KLE9BQU9JLElBQUksQ0FBQ0YsTUFBTUM7UUFDN0IsT0FBTztZQUNILElBQUksT0FBT0QsU0FBUyxVQUFVO2dCQUMxQix5REFBeUQ7Z0JBQ3pELGdFQUFnRTtnQkFDaEUsTUFBTSxJQUFJSSxNQUFNO1lBQ3BCO1lBQ0EsT0FBTyxJQUFJTixPQUFPRSxNQUFNQztRQUM1QjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNESSxhQUFhLFNBQVVDLElBQUk7UUFDdkIsSUFBSVIsT0FBT1MsS0FBSyxFQUFFO1lBQ2QsT0FBT1QsT0FBT1MsS0FBSyxDQUFDRDtRQUN4QixPQUFPO1lBQ0gsSUFBSUUsTUFBTSxJQUFJVixPQUFPUTtZQUNyQkUsSUFBSUMsSUFBSSxDQUFDO1lBQ1QsT0FBT0Q7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNERSxVQUFXLFNBQVNDLENBQUM7UUFDakIsT0FBT2IsT0FBT1ksUUFBUSxDQUFDQztJQUMzQjtJQUVBQyxVQUFXLFNBQVVDLEdBQUc7UUFDcEIsT0FBT0EsT0FDSCxPQUFPQSxJQUFJQyxFQUFFLEtBQUssY0FDbEIsT0FBT0QsSUFBSUUsS0FBSyxLQUFLLGNBQ3JCLE9BQU9GLElBQUlHLE1BQU0sS0FBSztJQUM5QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcz8xZDJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgcnVubmluZyBpbiBOb2RlanMsIHdpbGwgYmUgdW5kZWZpbmVkIGluIGEgYnJvd3Nlci5cbiAgICAgKiBJbiBhIGJyb3dzZXIsIGJyb3dzZXJpZnkgd29uJ3QgaW5jbHVkZSB0aGlzIGZpbGUgYW5kIHRoZSB3aG9sZSBtb2R1bGVcbiAgICAgKiB3aWxsIGJlIHJlc29sdmVkIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKi9cbiAgICBpc05vZGUgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIGZyb20gYW4gZXhpc3RpbmcgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBuZXdCdWZmZXJGcm9tOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIFNhZmVndWFyZCBmb3Igb2xkIE5vZGUuanMgdmVyc2lvbnMuIE9uIG5ld2VyIHZlcnNpb25zLFxuICAgICAgICAgICAgICAgIC8vIEJ1ZmZlci5mcm9tKG51bWJlcikgLyBCdWZmZXIobnVtYmVyLCBlbmNvZGluZykgYWxyZWFkeSB0aHJvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgXFxcImRhdGFcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNpemUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvY0J1ZmZlcjogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5hbGxvYykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICAgICAgYnVmLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIG91dCBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgdGhlIG9iamVjdCB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEJ1ZmZlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQnVmZmVyIDogZnVuY3Rpb24oYil7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYik7XG4gICAgfSxcblxuICAgIGlzU3RyZWFtIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm9uID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucGF1c2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5yZXN1bWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJpc05vZGUiLCJCdWZmZXIiLCJuZXdCdWZmZXJGcm9tIiwiZGF0YSIsImVuY29kaW5nIiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJFcnJvciIsImFsbG9jQnVmZmVyIiwic2l6ZSIsImFsbG9jIiwiYnVmIiwiZmlsbCIsImlzQnVmZmVyIiwiYiIsImlzU3RyZWFtIiwib2JqIiwib24iLCJwYXVzZSIsInJlc3VtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/nodejsUtils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */ function NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */ NodejsStreamInputAdapter.prototype._bindStream = function(stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream.on(\"data\", function(chunk) {\n        self.push({\n            data: chunk,\n            meta: {\n                percent: 0\n            }\n        });\n    }).on(\"error\", function(e) {\n        if (self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    }).on(\"end\", function() {\n        if (self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function() {\n    if (!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n    return true;\n};\nmodule.exports = NodejsStreamInputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywyRkFBeUI7QUFFckQ7Ozs7O0NBS0MsR0FDRCxTQUFTRSx5QkFBeUJDLFFBQVEsRUFBRUMsTUFBTTtJQUM5Q0gsY0FBY0ksSUFBSSxDQUFDLElBQUksRUFBRSxxQ0FBcUNGO0lBQzlELElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3RCLElBQUksQ0FBQ0MsV0FBVyxDQUFDSDtBQUNyQjtBQUVBTCxNQUFNUyxRQUFRLENBQUNOLDBCQUEwQkQ7QUFFekM7Ozs7Q0FJQyxHQUNEQyx5QkFBeUJPLFNBQVMsQ0FBQ0YsV0FBVyxHQUFHLFNBQVVILE1BQU07SUFDN0QsSUFBSU0sT0FBTyxJQUFJO0lBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdQO0lBQ2ZBLE9BQU9RLEtBQUs7SUFDWlIsT0FDS1MsRUFBRSxDQUFDLFFBQVEsU0FBVUMsS0FBSztRQUN2QkosS0FBS0ssSUFBSSxDQUFDO1lBQ05DLE1BQU1GO1lBQ05HLE1BQU87Z0JBQ0hDLFNBQVU7WUFDZDtRQUNKO0lBQ0osR0FDQ0wsRUFBRSxDQUFDLFNBQVMsU0FBVU0sQ0FBQztRQUNwQixJQUFHVCxLQUFLVSxRQUFRLEVBQUU7WUFDZCxJQUFJLENBQUNDLGNBQWMsR0FBR0Y7UUFDMUIsT0FBTztZQUNIVCxLQUFLWSxLQUFLLENBQUNIO1FBQ2Y7SUFDSixHQUNDTixFQUFFLENBQUMsT0FBTztRQUNQLElBQUdILEtBQUtVLFFBQVEsRUFBRTtZQUNkVixLQUFLSixjQUFjLEdBQUc7UUFDMUIsT0FBTztZQUNISSxLQUFLYSxHQUFHO1FBQ1o7SUFDSjtBQUNSO0FBQ0FyQix5QkFBeUJPLFNBQVMsQ0FBQ0csS0FBSyxHQUFHO0lBQ3ZDLElBQUcsQ0FBQ1gsY0FBY1EsU0FBUyxDQUFDRyxLQUFLLENBQUNQLElBQUksQ0FBQyxJQUFJLEdBQUc7UUFDMUMsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDTSxPQUFPLENBQUNDLEtBQUs7SUFDbEIsT0FBTztBQUNYO0FBQ0FWLHlCQUF5Qk8sU0FBUyxDQUFDZSxNQUFNLEdBQUc7SUFDeEMsSUFBRyxDQUFDdkIsY0FBY1EsU0FBUyxDQUFDZSxNQUFNLENBQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHO1FBQzNDLE9BQU87SUFDWDtJQUVBLElBQUcsSUFBSSxDQUFDQyxjQUFjLEVBQUU7UUFDcEIsSUFBSSxDQUFDaUIsR0FBRztJQUNaLE9BQU87UUFDSCxJQUFJLENBQUNaLE9BQU8sQ0FBQ2EsTUFBTTtJQUN2QjtJQUVBLE9BQU87QUFDWDtBQUVBQyxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcz81ZTJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHVzZSBhIG5vZGVqcyBzdHJlYW0gYXMgc291cmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgZW50cnkgZm9yIHRoaXMgc3RyZWFtLlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIoZmlsZW5hbWUsIHN0cmVhbSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIk5vZGVqcyBzdHJlYW0gaW5wdXQgYWRhcHRlciBmb3IgXCIgKyBmaWxlbmFtZSk7XG4gICAgdGhpcy5fdXBzdHJlYW1FbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2JpbmRTdHJlYW0oc3RyZWFtKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBzdHJlYW0gYW5kIGJpbmQgdGhlIGNhbGxiYWNrcyBvbiBpdC5cbiAqIERvIHRoaXMgQVNBUCBvbiBub2RlIDAuMTAgISBBIGxhenkgYmluZGluZyBkb2Vzbid0IGFsd2F5cyB3b3JrLlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbSB0byB1c2UuXG4gKi9cbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUuX2JpbmRTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICBzdHJlYW1cbiAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogY2h1bmssXG4gICAgICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl91cHN0cmVhbUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkdlbmVyaWNXb3JrZXIiLCJOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIiLCJmaWxlbmFtZSIsInN0cmVhbSIsImNhbGwiLCJfdXBzdHJlYW1FbmRlZCIsIl9iaW5kU3RyZWFtIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJzZWxmIiwiX3N0cmVhbSIsInBhdXNlIiwib24iLCJjaHVuayIsInB1c2giLCJkYXRhIiwibWV0YSIsInBlcmNlbnQiLCJlIiwiaXNQYXVzZWQiLCJnZW5lcmF0ZWRFcnJvciIsImVycm9yIiwiZW5kIiwicmVzdW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!************************************************************************!*\
  !*** ../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Readable = (__webpack_require__(/*! readable-stream */ \"(ssr)/../../node_modules/readable-stream/readable.js\").Readable);\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/ function NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n    var self = this;\n    helper.on(\"data\", function(data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if (updateCb) {\n            updateCb(meta);\n        }\n    }).on(\"error\", function(e) {\n        self.emit(\"error\", e);\n    }).on(\"end\", function() {\n        self.push(null);\n    });\n}\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\nmodule.exports = NodejsStreamOutputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLDZHQUFtQztBQUVsRCxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyw2REFBVTtBQUM5QkMsTUFBTUMsUUFBUSxDQUFDQywyQkFBMkJKO0FBRTFDOzs7Ozs7O0FBT0EsR0FDQSxTQUFTSSwwQkFBMEJDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQ3hEUCxTQUFTUSxJQUFJLENBQUMsSUFBSSxFQUFFRjtJQUNwQixJQUFJLENBQUNHLE9BQU8sR0FBR0o7SUFFZixJQUFJSyxPQUFPLElBQUk7SUFDZkwsT0FBT00sRUFBRSxDQUFDLFFBQVEsU0FBVUMsSUFBSSxFQUFFQyxJQUFJO1FBQ2xDLElBQUksQ0FBQ0gsS0FBS0ksSUFBSSxDQUFDRixPQUFPO1lBQ2xCRixLQUFLRCxPQUFPLENBQUNNLEtBQUs7UUFDdEI7UUFDQSxJQUFHUixVQUFVO1lBQ1RBLFNBQVNNO1FBQ2I7SUFDSixHQUNLRixFQUFFLENBQUMsU0FBUyxTQUFTSyxDQUFDO1FBQ25CTixLQUFLTyxJQUFJLENBQUMsU0FBU0Q7SUFDdkIsR0FDQ0wsRUFBRSxDQUFDLE9BQU87UUFDUEQsS0FBS0ksSUFBSSxDQUFDO0lBQ2Q7QUFDUjtBQUdBViwwQkFBMEJjLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHO0lBQ3hDLElBQUksQ0FBQ1YsT0FBTyxDQUFDVyxNQUFNO0FBQ3ZCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlci5qcz9kZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLCBSZWFkYWJsZSk7XG5cbi8qKlxuKiBBIG5vZGVqcyBzdHJlYW0gdXNpbmcgYSB3b3JrZXIgYXMgc291cmNlLlxuKiBAc2VlIHRoZSBTb3VyY2VXcmFwcGVyIGluIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbFxuKiBAY29uc3RydWN0b3JcbiogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHdyYXBwaW5nIHRoZSB3b3JrZXJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG5vZGVqcyBzdHJlYW0gb3B0aW9uc1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIoaGVscGVyLCBvcHRpb25zLCB1cGRhdGVDYikge1xuICAgIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5faGVscGVyID0gaGVscGVyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGhlbHBlci5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnB1c2goZGF0YSkpIHtcbiAgICAgICAgICAgIHNlbGYuX2hlbHBlci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHVwZGF0ZUNiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYihtZXRhKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgICAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiJdLCJuYW1lcyI6WyJSZWFkYWJsZSIsInJlcXVpcmUiLCJ1dGlscyIsImluaGVyaXRzIiwiTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciIsImhlbHBlciIsIm9wdGlvbnMiLCJ1cGRhdGVDYiIsImNhbGwiLCJfaGVscGVyIiwic2VsZiIsIm9uIiwiZGF0YSIsIm1ldGEiLCJwdXNoIiwicGF1c2UiLCJlIiwiZW1pdCIsInByb3RvdHlwZSIsIl9yZWFkIiwicmVzdW1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/object.js":
/*!**********************************************!*\
  !*** ../../node_modules/jszip/lib/object.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/../../node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/../../node_modules/jszip/lib/stream/StreamHelper.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/../../node_modules/jszip/lib/defaults.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/../../node_modules/jszip/lib/compressedObject.js\");\nvar ZipObject = __webpack_require__(/*! ./zipObject */ \"(ssr)/../../node_modules/jszip/lib/zipObject.js\");\nvar generate = __webpack_require__(/*! ./generate */ \"(ssr)/../../node_modules/jszip/lib/generate/index.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/../../node_modules/jszip/lib/nodejsUtils.js\");\nvar NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ \"(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\");\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */ var fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data), parent;\n    /*\n     * Correct options.\n     */ var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && o.unixPermissions & 0x4000) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && o.dosPermissions & 0x0010) {\n        o.dir = true;\n    }\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n    /*\n     * Convert content to fit.\n     */ var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n/*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */ };\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */ var parentFolder = function(path) {\n    if (path.slice(-1) === \"/\") {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf(\"/\");\n    return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */ var forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */ var folderAdd = function(name, createFolders) {\n    createFolders = typeof createFolders !== \"undefined\" ? createFolders : defaults.createFolders;\n    name = forceTrailingSlash(name);\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/ function isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */ load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */ forEach: function(cb) {\n        var filename, relativePath, file;\n        // ignore warning about unwanted properties because this.files is a null prototype object\n        /* eslint-disable-next-line guard-for-in */ for(filename in this.files){\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) {\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */ filter: function(search) {\n        var result = [];\n        this.forEach(function(relativePath, entry) {\n            if (search(relativePath, entry)) {\n                result.push(entry);\n            }\n        });\n        return result;\n    },\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */ file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            } else {\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */ folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */ remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for(var i = 0; i < kids.length; i++){\n                delete this.files[kids[i].name];\n            }\n        }\n        return this;\n    },\n    /**\n     * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.\n     */ generate: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */ generateInternalStream: function(options) {\n        var worker, opts = {};\n        try {\n            opts = utils.extend(options || {}, {\n                streamFiles: false,\n                compression: \"STORE\",\n                compressionOptions: null,\n                type: \"\",\n                platform: \"DOS\",\n                comment: null,\n                mimeType: \"application/zip\",\n                encodeFileName: utf8.utf8encode\n            });\n            opts.type = opts.type.toLowerCase();\n            opts.compression = opts.compression.toUpperCase();\n            // \"binarystring\" is preferred but the internals use \"string\".\n            if (opts.type === \"binarystring\") {\n                opts.type = \"string\";\n            }\n            if (!opts.type) {\n                throw new Error(\"No output type specified.\");\n            }\n            utils.checkSupport(opts.type);\n            // accept nodejs `process.platform`\n            if (opts.platform === \"darwin\" || opts.platform === \"freebsd\" || opts.platform === \"linux\" || opts.platform === \"sunos\") {\n                opts.platform = \"UNIX\";\n            }\n            if (opts.platform === \"win32\") {\n                opts.platform = \"DOS\";\n            }\n            var comment = opts.comment || this.comment || \"\";\n            worker = generate.generateWorker(this, opts, comment);\n        } catch (e) {\n            worker = new GenericWorker(\"error\");\n            worker.error(e);\n        }\n        return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQywwREFBUTtBQUMzQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyw0REFBUztBQUM3QixJQUFJRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLDBGQUF3QjtBQUNwRCxJQUFJRyxlQUFlSCxtQkFBT0EsQ0FBQyx3RkFBdUI7QUFDbEQsSUFBSUksV0FBV0osbUJBQU9BLENBQUMsa0VBQVk7QUFDbkMsSUFBSUssbUJBQW1CTCxtQkFBT0EsQ0FBQyxrRkFBb0I7QUFDbkQsSUFBSU0sWUFBWU4sbUJBQU9BLENBQUMsb0VBQWE7QUFDckMsSUFBSU8sV0FBV1AsbUJBQU9BLENBQUMsd0VBQVk7QUFDbkMsSUFBSVEsY0FBY1IsbUJBQU9BLENBQUMsd0VBQWU7QUFDekMsSUFBSVMsMkJBQTJCVCxtQkFBT0EsQ0FBQyxnSEFBbUM7QUFHMUU7Ozs7Ozs7Q0FPQyxHQUNELElBQUlVLFVBQVUsU0FBU0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLGVBQWU7SUFDOUMsNEJBQTRCO0lBQzVCLElBQUlDLFdBQVdiLE1BQU1jLFNBQVMsQ0FBQ0gsT0FDM0JJO0lBR0o7O0tBRUMsR0FFRCxJQUFJQyxJQUFJaEIsTUFBTWlCLE1BQU0sQ0FBQ0wsbUJBQW1CLENBQUMsR0FBR1Q7SUFDNUNhLEVBQUVFLElBQUksR0FBR0YsRUFBRUUsSUFBSSxJQUFJLElBQUlDO0lBQ3ZCLElBQUlILEVBQUVJLFdBQVcsS0FBSyxNQUFNO1FBQ3hCSixFQUFFSSxXQUFXLEdBQUdKLEVBQUVJLFdBQVcsQ0FBQ0MsV0FBVztJQUM3QztJQUVBLElBQUksT0FBT0wsRUFBRU0sZUFBZSxLQUFLLFVBQVU7UUFDdkNOLEVBQUVNLGVBQWUsR0FBR0MsU0FBU1AsRUFBRU0sZUFBZSxFQUFFO0lBQ3BEO0lBRUEsbUNBQW1DO0lBQ25DLElBQUlOLEVBQUVNLGVBQWUsSUFBS04s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SSxDQUFDQSxRQUFRSyxJQUFJLEVBQUU7WUFDZkwsUUFBUUssSUFBSSxHQUFHO1FBQ25CO1FBQ0EsT0FBTyxJQUFJLENBQUNOLHNCQUFzQixDQUFDQyxTQUFTb0IsY0FBYyxDQUFDSDtJQUMvRDtBQUNKO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9vYmplY3QuanM/ZjEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZShcIi4vemlwT2JqZWN0XCIpO1xudmFyIGdlbmVyYXRlID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIgPSByZXF1aXJlKFwiLi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyXCIpO1xuXG5cbi8qKlxuICogQWRkIGEgZmlsZSBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWxPcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZmlsZS5cbiAqL1xudmFyIGZpbGVBZGQgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICAvLyBiZSBzdXJlIHN1YiBmb2xkZXJzIGV4aXN0XG4gICAgdmFyIGRhdGFUeXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpLFxuICAgICAgICBwYXJlbnQ7XG5cblxuICAgIC8qXG4gICAgICogQ29ycmVjdCBvcHRpb25zLlxuICAgICAqL1xuXG4gICAgdmFyIG8gPSB1dGlscy5leHRlbmQob3JpZ2luYWxPcHRpb25zIHx8IHt9LCBkZWZhdWx0cyk7XG4gICAgby5kYXRlID0gby5kYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgaWYgKG8uY29tcHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IG8uY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG8udW5peFBlcm1pc3Npb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG8udW5peFBlcm1pc3Npb25zID0gcGFyc2VJbnQoby51bml4UGVybWlzc2lvbnMsIDgpO1xuICAgIH1cblxuICAgIC8vIFVOWF9JRkRJUiAgMDA0MDAwMCBzZWUgemlwaW5mby5jXG4gICAgaWYgKG8udW5peFBlcm1pc3Npb25zICYmIChvLnVuaXhQZXJtaXNzaW9ucyAmIDB4NDAwMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBCaXQgNCAgICBEaXJlY3RvcnlcbiAgICBpZiAoby5kb3NQZXJtaXNzaW9ucyAmJiAoby5kb3NQZXJtaXNzaW9ucyAmIDB4MDAxMCkpIHtcbiAgICAgICAgby5kaXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvLmRpcikge1xuICAgICAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoby5jcmVhdGVGb2xkZXJzICYmIChwYXJlbnQgPSBwYXJlbnRGb2xkZXIobmFtZSkpKSB7XG4gICAgICAgIGZvbGRlckFkZC5jYWxsKHRoaXMsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzVW5pY29kZVN0cmluZyA9IGRhdGFUeXBlID09PSBcInN0cmluZ1wiICYmIG8uYmluYXJ5ID09PSBmYWxzZSAmJiBvLmJhc2U2NCA9PT0gZmFsc2U7XG4gICAgaWYgKCFvcmlnaW5hbE9wdGlvbnMgfHwgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5iaW5hcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgby5iaW5hcnkgPSAhaXNVbmljb2RlU3RyaW5nO1xuICAgIH1cblxuXG4gICAgdmFyIGlzQ29tcHJlc3NlZEVtcHR5ID0gKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSAmJiBkYXRhLnVuY29tcHJlc3NlZFNpemUgPT09IDA7XG5cbiAgICBpZiAoaXNDb21wcmVzc2VkRW1wdHkgfHwgby5kaXIgfHwgIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgby5iYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgby5iaW5hcnkgPSB0cnVlO1xuICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgby5jb21wcmVzc2lvbiA9IFwiU1RPUkVcIjtcbiAgICAgICAgZGF0YVR5cGUgPSBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29udmVydCBjb250ZW50IHRvIGZpdC5cbiAgICAgKi9cblxuICAgIHZhciB6aXBPYmplY3RDb250ZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgfHwgZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmIChub2RlanNVdGlscy5pc05vZGUgJiYgbm9kZWpzVXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IG5ldyBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIobmFtZSwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgemlwT2JqZWN0Q29udGVudCA9IHV0aWxzLnByZXBhcmVDb250ZW50KG5hbWUsIGRhdGEsIG8uYmluYXJ5LCBvLm9wdGltaXplZEJpbmFyeVN0cmluZywgby5iYXNlNjQpO1xuICAgIH1cblxuICAgIHZhciBvYmplY3QgPSBuZXcgWmlwT2JqZWN0KG5hbWUsIHppcE9iamVjdENvbnRlbnQsIG8pO1xuICAgIHRoaXMuZmlsZXNbbmFtZV0gPSBvYmplY3Q7XG4gICAgLypcbiAgICBUT0RPOiB3ZSBjYW4ndCB0aHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSB3ZSBoYXZlIGFzeW5jIHByb21pc2VzXG4gICAgKHdlIGNhbiBoYXZlIGEgcHJvbWlzZSBvZiBhIERhdGUoKSBmb3IgZXhhbXBsZSkgYnV0IHJldHVybmluZyBhXG4gICAgcHJvbWlzZSBpcyB1c2VsZXNzIGJlY2F1c2UgZmlsZShuYW1lLCBkYXRhKSByZXR1cm5zIHRoZSBKU1ppcFxuICAgIG9iamVjdCBmb3IgY2hhaW5pbmcuIFNob3VsZCB3ZSBicmVhayB0aGF0IHRvIGFsbG93IHRoZSB1c2VyXG4gICAgdG8gY2F0Y2ggdGhlIGVycm9yID9cblxuICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoemlwT2JqZWN0Q29udGVudClcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG4gICAgKi9cbn07XG5cbi8qKlxuICogRmluZCB0aGUgcGFyZW50IGZvbGRlciBvZiB0aGUgcGF0aC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB1c2VcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHBhcmVudCBmb2xkZXIsIG9yIFwiXCJcbiAqL1xudmFyIHBhcmVudEZvbGRlciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2xpY2UoLTEpID09PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09IFwidW5kZWZpbmVkXCIpID8gY3JlYXRlRm9sZGVycyA6IGRlZmF1bHRzLmNyZWF0ZUZvbGRlcnM7XG5cbiAgICBuYW1lID0gZm9yY2VUcmFpbGluZ1NsYXNoKG5hbWUpO1xuXG4gICAgLy8gRG9lcyB0aGlzIGZvbGRlciBhbHJlYWR5IGV4aXN0P1xuICAgIGlmICghdGhpcy5maWxlc1tuYW1lXSkge1xuICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgbnVsbCwge1xuICAgICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogY3JlYXRlRm9sZGVyc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmlsZXNbbmFtZV07XG59O1xuXG4vKipcbiogQ3Jvc3Mtd2luZG93LCBjcm9zcy1Ob2RlLWNvbnRleHQgcmVndWxhciBleHByZXNzaW9uIGRldGVjdGlvblxuKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3QgQW55dGhpbmdcbiogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbixcbiogZmFsc2Ugb3RoZXJ3aXNlXG4qL1xuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xufVxuXG4vLyByZXR1cm4gdGhlIGFjdHVhbCBwcm90b3R5cGUgb2YgSlNaaXBcbnZhciBvdXQgPSB7XG4gICAgLyoqXG4gICAgICogQHNlZSBsb2FkQXN5bmNcbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGVudHJ5IGF0IHRoaXMgZm9sZGVyIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBjYWxsYmFjayBmdW5jdGlvbjpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSwgcmVsYXRpdmVQYXRoLCBmaWxlO1xuICAgICAgICAvLyBpZ25vcmUgd2FybmluZyBhYm91dCB1bndhbnRlZCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhpcy5maWxlcyBpcyBhIG51bGwgcHJvdG90eXBlIG9iamVjdFxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluICovXG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gZmlsZW5hbWUuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgZmlsZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGggJiYgZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCkgeyAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICAgICAgY2IocmVsYXRpdmVQYXRoLCBmaWxlKTsgLy8gVE9ETyByZXZlcnNlIHRoZSBwYXJhbWV0ZXJzID8gbmVlZCB0byBiZSBjbGVhbiBBTkQgY29uc2lzdGVudCB3aXRoIHRoZSBmaWx0ZXIgc2VhcmNoIGZuLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG5lc3RlZCBmaWxlcy9mb2xkZXJzIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZWFyY2ggdGhlIHByZWRpY2F0ZSB0byB1c2UgOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKHJlbGF0aXZlUGF0aCwgZW50cnkpKSB7IC8vIHRoZSBmaWxlIG1hdGNoZXMgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWxlIHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfFJlZ0V4cH0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBhZGQgKGlmIGRhdGEgaXMgZGVmaW5lZCksXG4gICAgICogdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZCAoaWYgbm8gZGF0YSkgb3IgYSByZWdleCB0byBtYXRjaCBmaWxlcy5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhICBUaGUgZmlsZSBkYXRhLCBlaXRoZXIgcmF3IG9yIGJhc2U2NCBlbmNvZGVkXG4gICAgICogQHBhcmFtICAge09iamVjdH0gbyAgICAgRmlsZSBvcHRpb25zXG4gICAgICogQHJldHVybiAge0pTWmlwfE9iamVjdHxBcnJheX0gdGhpcyBKU1ppcCBvYmplY3QgKHdoZW4gYWRkaW5nIGEgZmlsZSksXG4gICAgICogYSBmaWxlICh3aGVuIHNlYXJjaGluZyBieSBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIGZpbGVzICh3aGVuIHNlYXJjaGluZyBieSByZWdleCkuXG4gICAgICovXG4gICAgZmlsZTogZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4cCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWZpbGUuZGlyICYmIHJlZ2V4cC50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gdGV4dFxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIG5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgIW9iai5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZSAmJiAhZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIC8vIGZpbGVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWF5YmUgYSBmb2xkZXIsIGRlbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgICAgdmFyIGtpZHMgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNba2lkc1tpXS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhcyBhbiBpbnRlcm5hbCBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlIDpcbiAgICAgKiAtIGNvbXByZXNzaW9uLCBcIlNUT1JFXCIgYnkgZGVmYXVsdC5cbiAgICAgKiAtIHR5cGUsIFwiYmFzZTY0XCIgYnkgZGVmYXVsdC4gVmFsdWVzIGFyZSA6IHN0cmluZywgYmFzZTY0LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgYmxvYi5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBzdHJlYW1lZCB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUludGVybmFsU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB3b3JrZXIsIG9wdHMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdHMgPSB1dGlscy5leHRlbmQob3B0aW9ucyB8fCB7fSwge1xuICAgICAgICAgICAgICAgIHN0cmVhbUZpbGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgICBjb21tZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiLFxuICAgICAgICAgICAgICAgIGVuY29kZUZpbGVOYW1lOiB1dGY4LnV0ZjhlbmNvZGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3Npb24gPSBvcHRzLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIFwiYmluYXJ5c3RyaW5nXCIgaXMgcHJlZmVycmVkIGJ1dCB0aGUgaW50ZXJuYWxzIHVzZSBcInN0cmluZ1wiLlxuICAgICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgb3B0cy50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQob3B0cy50eXBlKTtcblxuICAgICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwiZGFyd2luXCIgfHxcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID09PSBcImZyZWVic2RcIiB8fFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwibGludXhcIiB8fFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwic3Vub3NcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiVU5JWFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IG9wdHMuY29tbWVudCB8fCB0aGlzLmNvbW1lbnQgfHwgXCJcIjtcbiAgICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICAgICAgd29ya2VyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHdvcmtlciwgb3B0cy50eXBlIHx8IFwic3RyaW5nXCIsIG9wdHMubWltZVR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlQXN5bmM6IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVOb2RlU3RyZWFtOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9IFwibm9kZWJ1ZmZlclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0ob3B0aW9ucykudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IG91dDtcbiJdLCJuYW1lcyI6WyJ1dGY4IiwicmVxdWlyZSIsInV0aWxzIiwiR2VuZXJpY1dvcmtlciIsIlN0cmVhbUhlbHBlciIsImRlZmF1bHRzIiwiQ29tcHJlc3NlZE9iamVjdCIsIlppcE9iamVjdCIsImdlbmVyYXRlIiwibm9kZWpzVXRpbHMiLCJOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIiLCJmaWxlQWRkIiwibmFtZSIsImRhdGEiLCJvcmlnaW5hbE9wdGlvbnMiLCJkYXRhVHlwZSIsImdldFR5cGVPZiIsInBhcmVudCIsIm8iLCJleHRlbmQiLCJkYXRlIiwiRGF0ZSIsImNvbXByZXNzaW9uIiwidG9VcHBlckNhc2UiLCJ1bml4UGVybWlzc2lvbnMiLCJwYXJzZUludCIsImRpciIsImRvc1Blcm1pc3Npb25zIiwiZm9yY2VUcmFpbGluZ1NsYXNoIiwiY3JlYXRlRm9sZGVycyIsInBhcmVudEZvbGRlciIsImZvbGRlckFkZCIsImNhbGwiLCJpc1VuaWNvZGVTdHJpbmciLCJiaW5hcnkiLCJiYXNlNjQiLCJpc0NvbXByZXNzZWRFbXB0eSIsInVuY29tcHJlc3NlZFNpemUiLCJsZW5ndGgiLCJ6aXBPYmplY3RDb250ZW50IiwiaXNOb2RlIiwiaXNTdHJlYW0iLCJwcmVwYXJlQ29udGVudCIsIm9wdGltaXplZEJpbmFyeVN0cmluZyIsIm9iamVjdCIsImZpbGVzIiwicGF0aCIsInNsaWNlIiwic3Vic3RyaW5nIiwibGFzdFNsYXNoIiwibGFzdEluZGV4T2YiLCJpc1JlZ0V4cCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwib3V0IiwibG9hZCIsIkVycm9yIiwiZm9yRWFjaCIsImNiIiwiZmlsZW5hbWUiLCJyZWxhdGl2ZVBhdGgiLCJmaWxlIiwicm9vdCIsImZpbHRlciIsInNlYXJjaCIsInJlc3VsdCIsImVudHJ5IiwicHVzaCIsImFyZ3VtZW50cyIsInJlZ2V4cCIsInRlc3QiLCJvYmoiLCJmb2xkZXIiLCJhcmciLCJuZXdGb2xkZXIiLCJyZXQiLCJjbG9uZSIsInJlbW92ZSIsImtpZHMiLCJpIiwiZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbSIsIm9wdGlvbnMiLCJ3b3JrZXIiLCJvcHRzIiwic3RyZWFtRmlsZXMiLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJ0eXBlIiwicGxhdGZvcm0iLCJjb21tZW50IiwibWltZVR5cGUiLCJlbmNvZGVGaWxlTmFtZSIsInV0ZjhlbmNvZGUiLCJ0b0xvd2VyQ2FzZSIsImNoZWNrU3VwcG9ydCIsImdlbmVyYXRlV29ya2VyIiwiZSIsImVycm9yIiwiZ2VuZXJhdGVBc3luYyIsIm9uVXBkYXRlIiwiYWNjdW11bGF0ZSIsImdlbmVyYXRlTm9kZVN0cmVhbSIsInRvTm9kZWpzU3RyZWFtIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/object.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/ArrayReader.js":
/*!**********************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/ArrayReader.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/../../node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n    for(var i = 0; i < this.data.length; i++){\n        data[i] = data[i] & 0xFF;\n    }\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ ArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);\n    for(var i = this.length - 4; i >= 0; --i){\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ ArrayReader.prototype.readAndCheckSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */ ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvQXJyYXlSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQyw2RUFBYztBQUN2QyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyw2REFBVTtBQUU5QixTQUFTRSxZQUFZQyxJQUFJO0lBQ3JCSixXQUFXSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtJQUN0QixJQUFJLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNGLElBQUksQ0FBQ0csTUFBTSxFQUFFRCxJQUFLO1FBQ3RDRixJQUFJLENBQUNFLEVBQUUsR0FBR0YsSUFBSSxDQUFDRSxFQUFFLEdBQUc7SUFDeEI7QUFDSjtBQUNBSixNQUFNTSxRQUFRLENBQUNMLGFBQWFIO0FBQzVCOztDQUVDLEdBQ0RHLFlBQVlNLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNKLENBQUM7SUFDckMsT0FBTyxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFJLENBQUNPLElBQUksR0FBR0wsRUFBRTtBQUNuQztBQUNBOztDQUVDLEdBQ0RILFlBQVlNLFNBQVMsQ0FBQ0csb0JBQW9CLEdBQUcsU0FBU0MsR0FBRztJQUNyRCxJQUFJQyxPQUFPRCxJQUFJRSxVQUFVLENBQUMsSUFDdEJDLE9BQU9ILElBQUlFLFVBQVUsQ0FBQyxJQUN0QkUsT0FBT0osSUFBSUUsVUFBVSxDQUFDLElBQ3RCRyxPQUFPTCxJQUFJRSxVQUFVLENBQUM7SUFDMUIsSUFBSyxJQUFJVCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBRyxFQUFFQSxFQUFHO1FBQ3ZDLElBQUksSUFBSSxDQUFDRixJQUFJLENBQUNFLEVBQUUsS0FBS1EsUUFBUSxJQUFJLENBQUNWLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEtBQUtVLFFBQVEsSUFBSSxDQUFDWixJQUFJLENBQUNFLElBQUksRUFBRSxLQUFLVyxRQUFRLElBQUksQ0FBQ2IsSUFBSSxDQUFDRSxJQUFJLEVBQUUsS0FBS1ksTUFBTTtZQUM5RyxPQUFPWixJQUFJLElBQUksQ0FBQ0ssSUFBSTtRQUN4QjtJQUNKO0lBRUEsT0FBTyxDQUFDO0FBQ1o7QUFDQTs7Q0FFQyxHQUNEUixZQUFZTSxTQUFTLENBQUNVLHFCQUFxQixHQUFHLFNBQVVOLEdBQUc7SUFDdkQsSUFBSUMsT0FBT0QsSUFBSUUsVUFBVSxDQUFDLElBQ3RCQyxPQUFPSCxJQUFJRSxVQUFVLENBQUMsSUFDdEJFLE9BQU9KLElBQUlFLFVBQVUsQ0FBQyxJQUN0QkcsT0FBT0wsSUFBSUUsVUFBVSxDQUFDLElBQ3RCWCxPQUFPLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQztJQUN6QixPQUFPTixTQUFTVixJQUFJLENBQUMsRUFBRSxJQUFJWSxTQUFTWixJQUFJLENBQUMsRUFBRSxJQUFJYSxTQUFTYixJQUFJLENBQUMsRUFBRSxJQUFJYyxTQUFTZCxJQUFJLENBQUMsRUFBRTtBQUN2RjtBQUNBOztDQUVDLEdBQ0RELFlBQVlNLFNBQVMsQ0FBQ1csUUFBUSxHQUFHLFNBQVNDLElBQUk7SUFDMUMsSUFBSSxDQUFDQyxXQUFXLENBQUNEO0lBQ2pCLElBQUdBLFNBQVMsR0FBRztRQUNYLE9BQU8sRUFBRTtJQUNiO0lBQ0EsSUFBSUUsU0FBUyxJQUFJLENBQUNuQixJQUFJLENBQUNvQixLQUFLLENBQUMsSUFBSSxDQUFDYixJQUFJLEdBQUcsSUFBSSxDQUFDYyxLQUFLLEVBQUUsSUFBSSxDQUFDZCxJQUFJLEdBQUcsSUFBSSxDQUFDYyxLQUFLLEdBQUdKO0lBQzlFLElBQUksQ0FBQ0ksS0FBSyxJQUFJSjtJQUNkLE9BQU9FO0FBQ1g7QUFDQUcsT0FBT0MsT0FBTyxHQUFHeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcz9kNTgzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKFwiLi9EYXRhUmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gJiAweEZGO1xuICAgIH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiJdLCJuYW1lcyI6WyJEYXRhUmVhZGVyIiwicmVxdWlyZSIsInV0aWxzIiwiQXJyYXlSZWFkZXIiLCJkYXRhIiwiY2FsbCIsImkiLCJsZW5ndGgiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImJ5dGVBdCIsInplcm8iLCJsYXN0SW5kZXhPZlNpZ25hdHVyZSIsInNpZyIsInNpZzAiLCJjaGFyQ29kZUF0Iiwic2lnMSIsInNpZzIiLCJzaWczIiwicmVhZEFuZENoZWNrU2lnbmF0dXJlIiwicmVhZERhdGEiLCJzaXplIiwiY2hlY2tPZmZzZXQiLCJyZXN1bHQiLCJzbGljZSIsImluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/DataReader.js":
/*!*********************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/DataReader.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */ checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */ checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */ setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */ skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */ byteAt: function() {\n    // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */ readInt: function(size) {\n        var result = 0, i;\n        this.checkOffset(size);\n        for(i = this.index + size - 1; i >= this.index; i--){\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */ readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */ readData: function() {\n    // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */ lastIndexOfSignature: function() {\n    // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */ readAndCheckSignature: function() {\n    // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */ readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, (dostime >> 21 & 0x0f) - 1, dostime >> 16 & 0x1f, dostime >> 11 & 0x1f, dostime >> 5 & 0x3f, (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvRGF0YVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLDZEQUFVO0FBRTlCLFNBQVNDLFdBQVdDLElBQUk7SUFDcEIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLE1BQU0sNEJBQTRCO0lBQzlDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRCxLQUFLQyxNQUFNO0lBQ3pCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUc7QUFDaEI7QUFDQUosV0FBV0ssU0FBUyxHQUFHO0lBQ25COzs7O0tBSUMsR0FDREMsYUFBYSxTQUFTQyxNQUFNO1FBQ3hCLElBQUksQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ0wsS0FBSyxHQUFHSTtJQUNqQztJQUNBOzs7O0tBSUMsR0FDREMsWUFBWSxTQUFTQyxRQUFRO1FBQ3pCLElBQUksSUFBSSxDQUFDUCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLEdBQUdLLFlBQVlBLFdBQVcsR0FBRztZQUNwRCxNQUFNLElBQUlDLE1BQU0sd0NBQXdDLElBQUksQ0FBQ1IsTUFBTSxHQUFHLHFCQUFzQk8sV0FBWTtRQUM1RztJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNERSxVQUFVLFNBQVNGLFFBQVE7UUFDdkIsSUFBSSxDQUFDRCxVQUFVLENBQUNDO1FBQ2hCLElBQUksQ0FBQ04sS0FBSyxHQUFHTTtJQUNqQjtJQUNBOzs7O0tBSUMsR0FDREcsTUFBTSxTQUFTQyxDQUFDO1FBQ1osSUFBSSxDQUFDRixRQUFRLENBQUMsSUFBSSxDQUFDUixLQUFLLEdBQUdVO0lBQy9CO0lBQ0E7Ozs7S0FJQyxHQUNEQyxRQUFRO0lBQ0osc0JBQXNCO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNEQyxTQUFTLFNBQVNDLElBQUk7UUFDbEIsSUFBSUMsU0FBUyxHQUNUQztRQUNKLElBQUksQ0FBQ1osV0FBVyxDQUFDVTtRQUNqQixJQUFLRSxJQUFJLElBQUksQ0FBQ2YsS0FBSyxHQUFHYSxPQUFPLEdBQUdFLEtBQUssSUFBSSxDQUFDZixLQUFLLEVBQUVlLElBQUs7WUFDbERELFNBQVMsQ0FBQ0EsVUFBVSxLQUFLLElBQUksQ0FBQ0gsTUFBTSxDQUFDSTtRQUN6QztRQUNBLElBQUksQ0FBQ2YsS0FBSyxJQUFJYTtRQUNkLE9BQU9DO0lBQ1g7SUFDQTs7OztLQUlDLEdBQ0RFLFlBQVksU0FBU0gsSUFBSTtRQUNyQixPQUFPbEIsTUFBTXNCLFdBQVcsQ0FBQyxVQUFVLElBQUksQ0FBQ0MsUUFBUSxDQUFDTDtJQUNyRDtJQUNBOzs7O0tBSUMsR0FDREssVUFBVTtJQUNOLHNCQUFzQjtJQUMxQjtJQUNBOzs7O0tBSUMsR0FDREMsc0JBQXNCO0lBQ2xCLHNCQUFzQjtJQUMxQjtJQUNBOzs7O0tBSUMsR0FDREMsdUJBQXVCO0lBQ25CLHNCQUFzQjtJQUMxQjtJQUNBOzs7S0FHQyxHQUNEQyxVQUFVO1FBQ04sSUFBSUMsVUFBVSxJQUFJLENBQUNWLE9BQU8sQ0FBQztRQUMzQixPQUFPLElBQUlXLEtBQUtBLEtBQUtDLEdBQUcsQ0FDcEIsQ0FBQyxXQUFZLEtBQU0sSUFBRyxJQUFLLE1BQzNCLENBQUMsV0FBWSxLQUFNLElBQUcsSUFBSyxHQUMzQixXQUFZLEtBQU0sTUFDbEIsV0FBWSxLQUFNLE1BQ2xCLFdBQVksSUFBSyxNQUNqQixDQUFDRixVQUFVLElBQUcsS0FBTSxLQUFLLFNBQVM7SUFDMUM7QUFDSjtBQUNBRyxPQUFPQyxPQUFPLEdBQUc3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0RhdGFSZWFkZXIuanM/N2JiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gRGF0YVJlYWRlcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTsgLy8gdHlwZSA6IHNlZSBpbXBsZW1lbnRhdGlvblxuICAgIHRoaXMubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy56ZXJvID0gMDtcbn1cbkRhdGFSZWFkZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG9mZnNldCB3aWxsIG5vdCBnbyB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvZmZzZXQgdGhlIGFkZGl0aW9uYWwgb2Zmc2V0IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgb2Zmc2V0IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgodGhpcy5pbmRleCArIG9mZnNldCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggd2lsbCBub3QgYmUgdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3SW5kZXggdGhlIGluZGV4IHRvIGNoZWNrLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja0luZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLnplcm8gKyBuZXdJbmRleCB8fCBuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuZCBvZiBkYXRhIHJlYWNoZWQgKGRhdGEgbGVuZ3RoID0gXCIgKyB0aGlzLmxlbmd0aCArIFwiLCBhc2tlZCBpbmRleCA9IFwiICsgKG5ld0luZGV4KSArIFwiKS4gQ29ycnVwdGVkIHppcCA/XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCBUaGUgbmV3IGluZGV4LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBzZXRJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KG5ld0luZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ld0luZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGUgbmV4dCBuIGJ5dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2tpcDogZnVuY3Rpb24obikge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuaW5kZXggKyBuKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIHRoZSBpbmRleCB0byB1c2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhIGJ5dGUuXG4gICAgICovXG4gICAgYnl0ZUF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IG51bWJlciB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjb3JyZXNwb25kaW5nIG51bWJlci5cbiAgICAgKi9cbiAgICByZWFkSW50OiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAgICAgZm9yIChpID0gdGhpcy5pbmRleCArIHNpemUgLSAxOyBpID49IHRoaXMuaW5kZXg7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA4KSArIHRoaXMuYnl0ZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBzdHJpbmcgd2l0aCBhIGdpdmVuIGJ5dGUgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgY29ycmVzcG9uZGluZyBzdHJpbmcuXG4gICAgICovXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5yZWFkRGF0YShzaXplKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcmF3IGRhdGEgd2l0aG91dCBjb252ZXJzaW9uLCA8c2l6ZT4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHJhdyBkYXRhLCBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYy5cbiAgICAgKi9cbiAgICByZWFkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHppcCBzaWduYXR1cmUgKDQgYnl0ZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIHNpZ25hdHVyZSB0byBmaW5kLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICAgICAoKGRvc3RpbWUgPj4gMjUpICYgMHg3ZikgKyAxOTgwLCAvLyB5ZWFyXG4gICAgICAgICAgICAoKGRvc3RpbWUgPj4gMjEpICYgMHgwZikgLSAxLCAvLyBtb250aFxuICAgICAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgICAgICAoZG9zdGltZSA+PiAxMSkgJiAweDFmLCAvLyBob3VyXG4gICAgICAgICAgICAoZG9zdGltZSA+PiA1KSAmIDB4M2YsIC8vIG1pbnV0ZVxuICAgICAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiRGF0YVJlYWRlciIsImRhdGEiLCJsZW5ndGgiLCJpbmRleCIsInplcm8iLCJwcm90b3R5cGUiLCJjaGVja09mZnNldCIsIm9mZnNldCIsImNoZWNrSW5kZXgiLCJuZXdJbmRleCIsIkVycm9yIiwic2V0SW5kZXgiLCJza2lwIiwibiIsImJ5dGVBdCIsInJlYWRJbnQiLCJzaXplIiwicmVzdWx0IiwiaSIsInJlYWRTdHJpbmciLCJ0cmFuc2Zvcm1UbyIsInJlYWREYXRhIiwibGFzdEluZGV4T2ZTaWduYXR1cmUiLCJyZWFkQW5kQ2hlY2tTaWduYXR1cmUiLCJyZWFkRGF0ZSIsImRvc3RpbWUiLCJEYXRlIiwiVVRDIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/DataReader.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!***************************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/../../node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n/**\n * @see DataReader.readData\n */ NodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLG1CQUFtQkMsbUJBQU9BLENBQUMseUZBQW9CO0FBQ25ELElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLDZEQUFVO0FBRTlCLFNBQVNFLGlCQUFpQkMsSUFBSTtJQUMxQkosaUJBQWlCSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtBQUNoQztBQUNBRixNQUFNSSxRQUFRLENBQUNILGtCQUFrQkg7QUFFakM7O0NBRUMsR0FDREcsaUJBQWlCSSxTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtJQUNqQixJQUFJRSxTQUFTLElBQUksQ0FBQ1AsSUFBSSxDQUFDUSxLQUFLLENBQUMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDRCxJQUFJLEdBQUcsSUFBSSxDQUFDQyxLQUFLLEdBQUdMO0lBQzlFLElBQUksQ0FBQ0ssS0FBSyxJQUFJTDtJQUNkLE9BQU9FO0FBQ1g7QUFDQUksT0FBT0MsT0FBTyxHQUFHYiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL05vZGVCdWZmZXJSZWFkZXIuanM/OTJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBVaW50OEFycmF5UmVhZGVyID0gcmVxdWlyZShcIi4vVWludDhBcnJheVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIl0sIm5hbWVzIjpbIlVpbnQ4QXJyYXlSZWFkZXIiLCJyZXF1aXJlIiwidXRpbHMiLCJOb2RlQnVmZmVyUmVhZGVyIiwiZGF0YSIsImNhbGwiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInJlYWREYXRhIiwic2l6ZSIsImNoZWNrT2Zmc2V0IiwicmVzdWx0Iiwic2xpY2UiLCJ6ZXJvIiwiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/NodeBufferReader.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/StringReader.js":
/*!***********************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/StringReader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/../../node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ StringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ StringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ StringReader.prototype.readAndCheckSignature = function(sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */ StringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUMsNkVBQWM7QUFDdkMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMsNkRBQVU7QUFFOUIsU0FBU0UsYUFBYUMsSUFBSTtJQUN0QkosV0FBV0ssSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDMUI7QUFDQUYsTUFBTUksUUFBUSxDQUFDSCxjQUFjSDtBQUM3Qjs7Q0FFQyxHQUNERyxhQUFhSSxTQUFTLENBQUNDLE1BQU0sR0FBRyxTQUFTQyxDQUFDO0lBQ3RDLE9BQU8sSUFBSSxDQUFDTCxJQUFJLENBQUNNLFVBQVUsQ0FBQyxJQUFJLENBQUNDLElBQUksR0FBR0Y7QUFDNUM7QUFDQTs7Q0FFQyxHQUNETixhQUFhSSxTQUFTLENBQUNLLG9CQUFvQixHQUFHLFNBQVNDLEdBQUc7SUFDdEQsT0FBTyxJQUFJLENBQUNULElBQUksQ0FBQ1UsV0FBVyxDQUFDRCxPQUFPLElBQUksQ0FBQ0YsSUFBSTtBQUNqRDtBQUNBOztDQUVDLEdBQ0RSLGFBQWFJLFNBQVMsQ0FBQ1EscUJBQXFCLEdBQUcsU0FBVUYsR0FBRztJQUN4RCxJQUFJVCxPQUFPLElBQUksQ0FBQ1ksUUFBUSxDQUFDO0lBQ3pCLE9BQU9ILFFBQVFUO0FBQ25CO0FBQ0E7O0NBRUMsR0FDREQsYUFBYUksU0FBUyxDQUFDUyxRQUFRLEdBQUcsU0FBU0MsSUFBSTtJQUMzQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Q7SUFDakIsb0VBQW9FO0lBQ3BFLElBQUlFLFNBQVMsSUFBSSxDQUFDZixJQUFJLENBQUNnQixLQUFLLENBQUMsSUFBSSxDQUFDVCxJQUFJLEdBQUcsSUFBSSxDQUFDVSxLQUFLLEVBQUUsSUFBSSxDQUFDVixJQUFJLEdBQUcsSUFBSSxDQUFDVSxLQUFLLEdBQUdKO0lBQzlFLElBQUksQ0FBQ0ksS0FBSyxJQUFJSjtJQUNkLE9BQU9FO0FBQ1g7QUFDQUcsT0FBT0MsT0FBTyxHQUFHcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanM/Yzg2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBEYXRhUmVhZGVyID0gcmVxdWlyZShcIi4vRGF0YVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gU3RyaW5nUmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhTdHJpbmdSZWFkZXIsIERhdGFSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnplcm8gKyBpKTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0SW5kZXhPZihzaWcpIC0gdGhpcy56ZXJvO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgcmV0dXJuIHNpZyA9PT0gZGF0YTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgLy8gdGhpcyB3aWxsIHdvcmsgYmVjYXVzZSB0aGUgY29uc3RydWN0b3IgYXBwbGllZCB0aGUgXCImIDB4ZmZcIiBtYXNrLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nUmVhZGVyO1xuIl0sIm5hbWVzIjpbIkRhdGFSZWFkZXIiLCJyZXF1aXJlIiwidXRpbHMiLCJTdHJpbmdSZWFkZXIiLCJkYXRhIiwiY2FsbCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiYnl0ZUF0IiwiaSIsImNoYXJDb2RlQXQiLCJ6ZXJvIiwibGFzdEluZGV4T2ZTaWduYXR1cmUiLCJzaWciLCJsYXN0SW5kZXhPZiIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsInJlYWREYXRhIiwic2l6ZSIsImNoZWNrT2Zmc2V0IiwicmVzdWx0Iiwic2xpY2UiLCJpbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/StringReader.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!***************************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/../../node_modules/jszip/lib/reader/ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */ Uint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGNBQWNDLG1CQUFPQSxDQUFDLCtFQUFlO0FBQ3pDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLDZEQUFVO0FBRTlCLFNBQVNFLGlCQUFpQkMsSUFBSTtJQUMxQkosWUFBWUssSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDM0I7QUFDQUYsTUFBTUksUUFBUSxDQUFDSCxrQkFBa0JIO0FBQ2pDOztDQUVDLEdBQ0RHLGlCQUFpQkksU0FBUyxDQUFDQyxRQUFRLEdBQUcsU0FBU0MsSUFBSTtJQUMvQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Q7SUFDakIsSUFBR0EsU0FBUyxHQUFHO1FBQ1gsaUZBQWlGO1FBQ2pGLE9BQU8sSUFBSUUsV0FBVztJQUMxQjtJQUNBLElBQUlDLFNBQVMsSUFBSSxDQUFDUixJQUFJLENBQUNTLFFBQVEsQ0FBQyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssR0FBR047SUFDakYsSUFBSSxDQUFDTSxLQUFLLElBQUlOO0lBQ2QsT0FBT0c7QUFDWDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcz8zODdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZShcIi4vQXJyYXlSZWFkZXJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIl0sIm5hbWVzIjpbIkFycmF5UmVhZGVyIiwicmVxdWlyZSIsInV0aWxzIiwiVWludDhBcnJheVJlYWRlciIsImRhdGEiLCJjYWxsIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJyZWFkRGF0YSIsInNpemUiLCJjaGVja09mZnNldCIsIlVpbnQ4QXJyYXkiLCJyZXN1bHQiLCJzdWJhcnJheSIsInplcm8iLCJpbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/Uint8ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/reader/readerFor.js":
/*!********************************************************!*\
  !*** ../../node_modules/jszip/lib/reader/readerFor.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/../../node_modules/jszip/lib/reader/ArrayReader.js\");\nvar StringReader = __webpack_require__(/*! ./StringReader */ \"(ssr)/../../node_modules/jszip/lib/reader/StringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ \"(ssr)/../../node_modules/jszip/lib/reader/NodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/../../node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */ module.exports = function(data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMsaUVBQVk7QUFDbEMsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsK0VBQWU7QUFDekMsSUFBSUcsZUFBZUgsbUJBQU9BLENBQUMsaUZBQWdCO0FBQzNDLElBQUlJLG1CQUFtQkosbUJBQU9BLENBQUMseUZBQW9CO0FBQ25ELElBQUlLLG1CQUFtQkwsbUJBQU9BLENBQUMseUZBQW9CO0FBRW5EOzs7O0NBSUMsR0FDRE0sT0FBT0MsT0FBTyxHQUFHLFNBQVVDLElBQUk7SUFDM0IsSUFBSUMsT0FBT1YsTUFBTVcsU0FBUyxDQUFDRjtJQUMzQlQsTUFBTVksWUFBWSxDQUFDRjtJQUNuQixJQUFJQSxTQUFTLFlBQVksQ0FBQ1IsUUFBUVcsVUFBVSxFQUFFO1FBQzFDLE9BQU8sSUFBSVQsYUFBYUs7SUFDNUI7SUFDQSxJQUFJQyxTQUFTLGNBQWM7UUFDdkIsT0FBTyxJQUFJTCxpQkFBaUJJO0lBQ2hDO0lBQ0EsSUFBSVAsUUFBUVcsVUFBVSxFQUFFO1FBQ3BCLE9BQU8sSUFBSVAsaUJBQWlCTixNQUFNYyxXQUFXLENBQUMsY0FBY0w7SUFDaEU7SUFDQSxPQUFPLElBQUlOLFlBQVlILE1BQU1jLFdBQVcsQ0FBQyxTQUFTTDtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL3JlYWRlckZvci5qcz85ZTFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuLi9zdXBwb3J0XCIpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZShcIi4vQXJyYXlSZWFkZXJcIik7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZShcIi4vU3RyaW5nUmVhZGVyXCIpO1xudmFyIE5vZGVCdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9Ob2RlQnVmZmVyUmVhZGVyXCIpO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9VaW50OEFycmF5UmVhZGVyXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJzdXBwb3J0IiwiQXJyYXlSZWFkZXIiLCJTdHJpbmdSZWFkZXIiLCJOb2RlQnVmZmVyUmVhZGVyIiwiVWludDhBcnJheVJlYWRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJkYXRhIiwidHlwZSIsImdldFR5cGVPZiIsImNoZWNrU3VwcG9ydCIsInVpbnQ4YXJyYXkiLCJ0cmFuc2Zvcm1UbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/reader/readerFor.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/signature.js":
/*!*************************************************!*\
  !*** ../../node_modules/jszip/lib/signature.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\b\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zaWduYXR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEseUJBQXlCLEdBQUc7QUFDNUJBLDJCQUEyQixHQUFHO0FBQzlCQSw2QkFBNkIsR0FBRztBQUNoQ0EsdUNBQXVDLEdBQUc7QUFDMUNBLG1DQUFtQyxHQUFHO0FBQ3RDQSx1QkFBdUIsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc2lnbmF0dXJlLmpzP2VkZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkxPQ0FMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAzXFx4MDRcIjtcbmV4cG9ydHMuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcXHgwMVxceDAyXCI7XG5leHBvcnRzLkNFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNVxceDA2XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSBcIlBLXFx4MDZcXHgwN1wiO1xuZXhwb3J0cy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXFx4MDZcXHgwNlwiO1xuZXhwb3J0cy5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXHgwOFwiO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJMT0NBTF9GSUxFX0hFQURFUiIsIkNFTlRSQUxfRklMRV9IRUFERVIiLCJDRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiREFUQV9ERVNDUklQVE9SIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/signature.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/ConvertWorker.js":
/*!************************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */ function ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ ConvertWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: utils.transformTo(this.destType, chunk.data),\n        meta: chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUMsbUZBQWlCO0FBQzdDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLDZEQUFVO0FBRTlCOzs7O0NBSUMsR0FDRCxTQUFTRSxjQUFjQyxRQUFRO0lBQzNCSixjQUFjSyxJQUFJLENBQUMsSUFBSSxFQUFFLHNCQUFzQkQ7SUFDL0MsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0FBQ3BCO0FBQ0FGLE1BQU1JLFFBQVEsQ0FBQ0gsZUFBZUg7QUFFOUI7O0NBRUMsR0FDREcsY0FBY0ksU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBVUMsS0FBSztJQUNsRCxJQUFJLENBQUNDLElBQUksQ0FBQztRQUNOQyxNQUFPVCxNQUFNVSxXQUFXLENBQUMsSUFBSSxDQUFDUixRQUFRLEVBQUVLLE1BQU1FLElBQUk7UUFDbERFLE1BQU9KLE1BQU1JLElBQUk7SUFDckI7QUFDSjtBQUNBQyxPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcz8yMTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY29udmVydCBjaHVua3MgdG8gYSBzcGVjaWZpZWQgdHlwZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RUeXBlIHRoZSBkZXN0aW5hdGlvbiB0eXBlLlxuICovXG5mdW5jdGlvbiBDb252ZXJ0V29ya2VyKGRlc3RUeXBlKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ29udmVydFdvcmtlciB0byBcIiArIGRlc3RUeXBlKTtcbiAgICB0aGlzLmRlc3RUeXBlID0gZGVzdFR5cGU7XG59XG51dGlscy5pbmhlcml0cyhDb252ZXJ0V29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNvbnZlcnRXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiB1dGlscy50cmFuc2Zvcm1Ubyh0aGlzLmRlc3RUeXBlLCBjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnRXb3JrZXI7XG4iXSwibmFtZXMiOlsiR2VuZXJpY1dvcmtlciIsInJlcXVpcmUiLCJ1dGlscyIsIkNvbnZlcnRXb3JrZXIiLCJkZXN0VHlwZSIsImNhbGwiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInByb2Nlc3NDaHVuayIsImNodW5rIiwicHVzaCIsImRhdGEiLCJ0cmFuc2Zvcm1UbyIsIm1ldGEiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/ConvertWorker.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/Crc32Probe.js":
/*!*********************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/../../node_modules/jszip/lib/crc32.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */ function Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Crc32Probe.prototype.processChunk = function(chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUMsbUZBQWlCO0FBQzdDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLDZEQUFVO0FBQzlCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDLDZEQUFVO0FBRTlCOzs7Q0FHQyxHQUNELFNBQVNHO0lBQ0xKLGNBQWNLLElBQUksQ0FBQyxJQUFJLEVBQUU7SUFDekIsSUFBSSxDQUFDQyxjQUFjLENBQUMsU0FBUztBQUNqQztBQUNBSCxNQUFNSSxRQUFRLENBQUNILFlBQVlKO0FBRTNCOztDQUVDLEdBQ0RJLFdBQVdJLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVVDLEtBQUs7SUFDL0MsSUFBSSxDQUFDQyxVQUFVLENBQUNULEtBQUssR0FBR0EsTUFBTVEsTUFBTUUsSUFBSSxFQUFFLElBQUksQ0FBQ0QsVUFBVSxDQUFDVCxLQUFLLElBQUk7SUFDbkUsSUFBSSxDQUFDVyxJQUFJLENBQUNIO0FBQ2Q7QUFDQUksT0FBT0MsT0FBTyxHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NyYzMyUHJvYmUuanM/Y2U5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xudmFyIGNyYzMyID0gcmVxdWlyZShcIi4uL2NyYzMyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgY3JjMzIgb2YgdGhlIGRhdGEgZmxvd2luZyB0aHJvdWdoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENyYzMyUHJvYmUoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiQ3JjMzJQcm9iZVwiKTtcbiAgICB0aGlzLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgMCk7XG59XG51dGlscy5pbmhlcml0cyhDcmMzMlByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkNyYzMyUHJvYmUucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMuc3RyZWFtSW5mby5jcmMzMiA9IGNyYzMyKGNodW5rLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKTtcbiAgICB0aGlzLnB1c2goY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ3JjMzJQcm9iZTtcbiJdLCJuYW1lcyI6WyJHZW5lcmljV29ya2VyIiwicmVxdWlyZSIsImNyYzMyIiwidXRpbHMiLCJDcmMzMlByb2JlIiwiY2FsbCIsIndpdGhTdHJlYW1JbmZvIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsInN0cmVhbUluZm8iLCJkYXRhIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/Crc32Probe.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!**************************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */ function DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ DataLengthProbe.prototype.processChunk = function(chunk) {\n    if (chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtRkFBaUI7QUFFN0M7Ozs7Q0FJQyxHQUNELFNBQVNFLGdCQUFnQkMsUUFBUTtJQUM3QkYsY0FBY0csSUFBSSxDQUFDLElBQUksRUFBRSx5QkFBeUJEO0lBQ2xELElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNoQixJQUFJLENBQUNFLGNBQWMsQ0FBQ0YsVUFBVTtBQUNsQztBQUNBSixNQUFNTyxRQUFRLENBQUNKLGlCQUFpQkQ7QUFFaEM7O0NBRUMsR0FDREMsZ0JBQWdCSyxTQUFTLENBQUNDLFlBQVksR0FBRyxTQUFVQyxLQUFLO0lBQ3BELElBQUdBLE9BQU87UUFDTixJQUFJQyxTQUFTLElBQUksQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ1IsUUFBUSxDQUFDLElBQUk7UUFDL0MsSUFBSSxDQUFDUSxVQUFVLENBQUMsSUFBSSxDQUFDUixRQUFRLENBQUMsR0FBR08sU0FBU0QsTUFBTUcsSUFBSSxDQUFDRixNQUFNO0lBQy9EO0lBQ0FULGNBQWNNLFNBQVMsQ0FBQ0MsWUFBWSxDQUFDSixJQUFJLENBQUMsSUFBSSxFQUFFSztBQUNwRDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlLmpzPzk2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiR2VuZXJpY1dvcmtlciIsIkRhdGFMZW5ndGhQcm9iZSIsInByb3BOYW1lIiwiY2FsbCIsIndpdGhTdHJlYW1JbmZvIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsImxlbmd0aCIsInN0cmVhbUluZm8iLCJkYXRhIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/DataLengthProbe.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/DataWorker.js":
/*!*********************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/DataWorker.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */ function DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n    this._tickScheduled = false;\n    dataP.then(function(data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if (!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function(e) {\n        self.error(e);\n    });\n}\nutils.inherits(DataWorker, GenericWorker);\n/**\n * @see GenericWorker.cleanUp\n */ DataWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n/**\n * @see GenericWorker.resume\n */ DataWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n/**\n * Trigger a tick a schedule an other call to this function.\n */ DataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if (this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if (!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n/**\n * Read and push a chunk.\n */ DataWorker.prototype._tick = function() {\n    if (this.isPaused || this.isFinished) {\n        return false;\n    }\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type){\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n                break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data: data,\n            meta: {\n                percent: this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\nmodule.exports = DataWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLDZEQUFVO0FBQzlCLElBQUlDLGdCQUFnQkQsbUJBQU9BLENBQUMsbUZBQWlCO0FBRTdDLG1DQUFtQztBQUNuQyx3Q0FBd0M7QUFDeEMsSUFBSUUscUJBQXFCLEtBQUs7QUFFOUI7Ozs7Q0FJQyxHQUNELFNBQVNDLFdBQVdDLEtBQUs7SUFDckJILGNBQWNJLElBQUksQ0FBQyxJQUFJLEVBQUU7SUFDekIsSUFBSUMsT0FBTyxJQUFJO0lBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFFWixJQUFJLENBQUNDLGNBQWMsR0FBRztJQUV0QlIsTUFBTVMsSUFBSSxDQUFDLFNBQVVILElBQUk7UUFDckJKLEtBQUtDLFdBQVcsR0FBRztRQUNuQkQsS0FBS0ksSUFBSSxHQUFHQTtRQUNaSixLQUFLRyxHQUFHLEdBQUdDLFFBQVFBLEtBQUtJLE1BQU0sSUFBSTtRQUNsQ1IsS0FBS0ssSUFBSSxHQUFHWixNQUFNZ0IsU0FBUyxDQUFDTDtRQUM1QixJQUFHLENBQUNKLEtBQUtVLFFBQVEsRUFBRTtZQUNmVixLQUFLVyxjQUFjO1FBQ3ZCO0lBQ0osR0FBRyxTQUFVQyxDQUFDO1FBQ1ZaLEtBQUthLEtBQUssQ0FBQ0Q7SUFDZjtBQUNKO0FBRUFuQixNQUFNcUIsUUFBUSxDQUFDakIsWUFBWUY7QUFFM0I7O0NBRUMsR0FDREUsV0FBV2tCLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHO0lBQzNCckIsY0FBY29CLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDakIsSUFBSSxDQUFDLElBQUk7SUFDekMsSUFBSSxDQUFDSyxJQUFJLEdBQUc7QUFDaEI7QUFFQTs7Q0FFQyxHQUNEUCxXQUFXa0IsU0FBUyxDQUFDRSxNQUFNLEdBQUc7SUFDMUIsSUFBRyxDQUFDdEIsY0FBY29CLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDbEIsSUFBSSxDQUFDLElBQUksR0FBRztRQUMzQyxPQUFPO0lBQ1g7SUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDTyxjQUFjLElBQUksSUFBSSxDQUFDTCxXQUFXLEVBQUU7UUFDMUMsSUFBSSxDQUFDSyxjQUFjLEdBQUc7UUFDdEJiLE1BQU15QixLQUFLLENBQUMsSUFBSSxDQUFDUCxjQUFjLEVBQUUsRUFBRSxFQUFFLElBQUk7SUFDN0M7SUFDQSxPQUFPO0FBQ1g7QUFFQTs7Q0FFQyxHQUNEZCxXQUFXa0IsU0FBUyxDQUFDSixjQUFjLEdBQUc7SUFDbEMsSUFBSSxDQUFDTCxjQUFjLEdBQUc7SUFDdEIsSUFBRyxJQUFJLENBQUNJLFFBQVEsSUFBSSxJQUFJLENBQUNTLFVBQVUsRUFBRTtRQUNqQztJQUNKO0lBQ0EsSUFBSSxDQUFDQyxLQUFLO0lBQ1YsSUFBRyxDQUFDLElBQUksQ0FBQ0QsVUFBVSxFQUFFO1FBQ2pCMUIsTUFBTXlCLEtBQUssQ0FBQyxJQUFJLENBQUNQLGNBQWMsRUFBRSxFQUFFLEVBQUUsSUFBSTtRQUN6QyxJQUFJLENBQUNMLGNBQWMsR0FBRztJQUMxQjtBQUNKO0FBRUE7O0NBRUMsR0FDRFQsV0FBV2tCLFNBQVMsQ0FBQ0ssS0FBSyxHQUFHO0lBRXpCLElBQUcsSUFBSSxDQUFDVixRQUFRLElBQUksSUFBSSxDQUFDUyxVQUFVLEVBQUU7UUFDakMsT0FBTztJQUNYO0lBRUEsSUFBSUUsT0FBT3pCO0lBQ1gsSUFBSVEsT0FBTyxNQUFNa0IsWUFBWUMsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ3JCLEdBQUcsRUFBRSxJQUFJLENBQUNELEtBQUssR0FBR21CO0lBQzdELElBQUksSUFBSSxDQUFDbkIsS0FBSyxJQUFJLElBQUksQ0FBQ0MsR0FBRyxFQUFFO1FBQ3hCLE1BQU07UUFDTixPQUFPLElBQUksQ0FBQ3NCLEdBQUc7SUFDbkIsT0FBTztRQUNILE9BQU8sSUFBSSxDQUFDcEIsSUFBSTtZQUNoQixLQUFLO2dCQUNERCxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDc0IsU0FBUyxDQUFDLElBQUksQ0FBQ3hCLEtBQUssRUFBRW9CO2dCQUN2QztZQUNKLEtBQUs7Z0JBQ0RsQixPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDdUIsUUFBUSxDQUFDLElBQUksQ0FBQ3pCLEtBQUssRUFBRW9CO2dCQUN0QztZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUNEbEIsT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ3dCLEtBQUssQ0FBQyxJQUFJLENBQUMxQixLQUFLLEVBQUVvQjtnQkFDbkM7UUFDSjtRQUNBLElBQUksQ0FBQ3BCLEtBQUssR0FBR29CO1FBQ2IsT0FBTyxJQUFJLENBQUNPLElBQUksQ0FBQztZQUNiekIsTUFBT0E7WUFDUDBCLE1BQU87Z0JBQ0hDLFNBQVUsSUFBSSxDQUFDNUIsR0FBRyxHQUFHLElBQUksQ0FBQ0QsS0FBSyxHQUFHLElBQUksQ0FBQ0MsR0FBRyxHQUFHLE1BQU07WUFDdkQ7UUFDSjtJQUNKO0FBQ0o7QUFFQTZCLE9BQU9DLE9BQU8sR0FBR3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vRGF0YVdvcmtlci5qcz9mZWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8vIHRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQgY2h1bmtzXG4vLyBUT0RPIGV4cG9zZSB0aGlzIGFzIGEgcHVibGljIHZhcmlhYmxlXG52YXIgREVGQVVMVF9CTE9DS19TSVpFID0gMTYgKiAxMDI0O1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgcmVhZHMgYSBjb250ZW50IGFuZCBlbWl0cyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHJvbWlzZX0gZGF0YVAgdGhlIHByb21pc2Ugb2YgdGhlIGRhdGEgdG8gc3BsaXRcbiAqL1xuZnVuY3Rpb24gRGF0YVdvcmtlcihkYXRhUCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFXb3JrZXJcIik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZGF0YUlzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLm1heCA9IDA7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuXG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YVAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLmRhdGFJc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5tYXggPSBkYXRhICYmIGRhdGEubGVuZ3RoIHx8IDA7XG4gICAgICAgIHNlbGYudHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKTtcbiAgICAgICAgaWYoIXNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3RpY2tBbmRSZXBlYXQoKTtcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgfSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKERhdGFXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5yZXN1bWVcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90aWNrU2NoZWR1bGVkICYmIHRoaXMuZGF0YUlzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3RpY2tBbmRSZXBlYXQsIFtdLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYSB0aWNrIGEgc2NoZWR1bGUgYW4gb3RoZXIgY2FsbCB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGlja0FuZFJlcGVhdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RpY2soKTtcbiAgICBpZighdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3RpY2tBbmRSZXBlYXQsIFtdLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwdXNoIGEgY2h1bmsuXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSBERUZBVUxUX0JMT0NLX1NJWkU7XG4gICAgdmFyIGRhdGEgPSBudWxsLCBuZXh0SW5kZXggPSBNYXRoLm1pbih0aGlzLm1heCwgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMubWF4KSB7XG4gICAgICAgIC8vIEVPRlxuICAgICAgICByZXR1cm4gdGhpcy5lbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2godGhpcy50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiB0aGlzLm1heCA/IHRoaXMuaW5kZXggLyB0aGlzLm1heCAqIDEwMCA6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhV29ya2VyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkdlbmVyaWNXb3JrZXIiLCJERUZBVUxUX0JMT0NLX1NJWkUiLCJEYXRhV29ya2VyIiwiZGF0YVAiLCJjYWxsIiwic2VsZiIsImRhdGFJc1JlYWR5IiwiaW5kZXgiLCJtYXgiLCJkYXRhIiwidHlwZSIsIl90aWNrU2NoZWR1bGVkIiwidGhlbiIsImxlbmd0aCIsImdldFR5cGVPZiIsImlzUGF1c2VkIiwiX3RpY2tBbmRSZXBlYXQiLCJlIiwiZXJyb3IiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImNsZWFuVXAiLCJyZXN1bWUiLCJkZWxheSIsImlzRmluaXNoZWQiLCJfdGljayIsInNpemUiLCJuZXh0SW5kZXgiLCJNYXRoIiwibWluIiwiZW5kIiwic3Vic3RyaW5nIiwic3ViYXJyYXkiLCJzbGljZSIsInB1c2giLCJtZXRhIiwicGVyY2VudCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/DataWorker.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js":
/*!************************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/GenericWorker.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */ function GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        \"data\": [],\n        \"end\": [],\n        \"error\": []\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */ push: function(chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */ end: function() {\n        if (this.isFinished) {\n            return false;\n        }\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */ error: function(e) {\n        if (this.isFinished) {\n            return false;\n        }\n        if (this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n            this.emit(\"error\", e);\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if (this.previous) {\n                this.previous.error(e);\n            }\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */ on: function(name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */ cleanUp: function() {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */ emit: function(name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++){\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */ pipe: function(next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */ registerPrevious: function(previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous = previous;\n        var self = this;\n        previous.on(\"data\", function(chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on(\"end\", function() {\n            self.end();\n        });\n        previous.on(\"error\", function(e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */ pause: function() {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n        if (this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */ resume: function() {\n        if (!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if (this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if (this.previous) {\n            this.previous.resume();\n        }\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */ flush: function() {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */ processChunk: function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */ withStreamInfo: function(key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */ mergeStreamInfo: function() {\n        for(var key in this.extraStreamInfo){\n            if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */ lock: function() {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n    /**\n     *\n     * Pretty print the workers chain.\n     */ toString: function() {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\nmodule.exports = GenericWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vR2VuZXJpY1dvcmtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTQSxjQUFjQyxJQUFJO0lBQ3ZCLHlCQUF5QjtJQUN6QixJQUFJLENBQUNBLElBQUksR0FBR0EsUUFBUTtJQUNwQix3REFBd0Q7SUFDeEQsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQztJQUNuQixxREFBcUQ7SUFDckQsSUFBSSxDQUFDQyxjQUFjLEdBQUc7SUFDdEIsc0ZBQXNGO0lBQ3RGLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUM7SUFDeEIsNkVBQTZFO0lBQzdFLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLCtFQUErRTtJQUMvRSxJQUFJLENBQUNDLFVBQVUsR0FBRztJQUNsQiw0RkFBNEY7SUFDNUYsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsc0JBQXNCO0lBQ3RCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2QsUUFBTyxFQUFFO1FBQ1QsT0FBTSxFQUFFO1FBQ1IsU0FBUSxFQUFFO0lBQ2Q7SUFDQSw4QkFBOEI7SUFDOUIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7QUFDcEI7QUFFQVQsY0FBY1UsU0FBUyxHQUFHO0lBQ3RCOzs7S0FHQyxHQUNEQyxNQUFPLFNBQVVDLEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxJQUFJLENBQUMsUUFBUUQ7SUFDdEI7SUFDQTs7O0tBR0MsR0FDREUsS0FBTTtRQUNGLElBQUksSUFBSSxDQUFDUixVQUFVLEVBQUU7WUFDakIsT0FBTztRQUNYO1FBRUEsSUFBSSxDQUFDUyxLQUFLO1FBQ1YsSUFBSTtZQUNBLElBQUksQ0FBQ0YsSUFBSSxDQUFDO1lBQ1YsSUFBSSxDQUFDRyxPQUFPO1lBQ1osSUFBSSxDQUFDVixVQUFVLEdBQUc7UUFDdEIsRUFBRSxPQUFPVyxHQUFHO1lBQ1IsSUFBSSxDQUFDSixJQUFJLENBQUMsU0FBU0k7UUFD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QUssWUFBWSxJQUFJLENBQUN6QyxJQUFJO1FBQzlCLElBQUksSUFBSSxDQUFDUSxRQUFRLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQ0EsUUFBUSxHQUFHLFNBQVNpQztRQUNwQyxPQUFPO1lBQ0gsT0FBT0E7UUFDWDtJQUNKO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzP2E1MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgIFwiZGF0YVwiOltdLFxuICAgICAgICBcImVuZFwiOltdLFxuICAgICAgICBcImVycm9yXCI6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5leHRyYVN0cmVhbUluZm8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RyZWFtSW5mb1trZXldID0gdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBzdHJlYW0gdG8gcHJldmVudCBmdXJ0aGVyIHVwZGF0ZXMgb24gdGhlIHdvcmtlcnMgY2hhaW4uXG4gICAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgYWxsIGNhbGxzIHRvIHBpcGUgd2lsbCBmYWlsLlxuICAgICAqL1xuICAgIGxvY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5sb2NrKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQcmV0dHkgcHJpbnQgdGhlIHdvcmtlcnMgY2hhaW4uXG4gICAgICovXG4gICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZSA9IFwiV29ya2VyIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMgKyBcIiAtPiBcIiArIG1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW5lcmljV29ya2VyO1xuIl0sIm5hbWVzIjpbIkdlbmVyaWNXb3JrZXIiLCJuYW1lIiwic3RyZWFtSW5mbyIsImdlbmVyYXRlZEVycm9yIiwiZXh0cmFTdHJlYW1JbmZvIiwiaXNQYXVzZWQiLCJpc0ZpbmlzaGVkIiwiaXNMb2NrZWQiLCJfbGlzdGVuZXJzIiwicHJldmlvdXMiLCJwcm90b3R5cGUiLCJwdXNoIiwiY2h1bmsiLCJlbWl0IiwiZW5kIiwiZmx1c2giLCJjbGVhblVwIiwiZSIsImVycm9yIiwib24iLCJsaXN0ZW5lciIsImFyZyIsImkiLCJsZW5ndGgiLCJjYWxsIiwicGlwZSIsIm5leHQiLCJyZWdpc3RlclByZXZpb3VzIiwiRXJyb3IiLCJtZXJnZVN0cmVhbUluZm8iLCJzZWxmIiwicHJvY2Vzc0NodW5rIiwicGF1c2UiLCJyZXN1bWUiLCJ3aXRoRXJyb3IiLCJ3aXRoU3RyZWFtSW5mbyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJsb2NrIiwidG9TdHJpbmciLCJtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/stream/StreamHelper.js":
/*!***********************************************************!*\
  !*** ../../node_modules/jszip/lib/stream/StreamHelper.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/ConvertWorker.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar base64 = __webpack_require__(/*! ../base64 */ \"(ssr)/../../node_modules/jszip/lib/base64.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nvar external = __webpack_require__(/*! ../external */ \"(ssr)/../../node_modules/jszip/lib/external.js\");\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ \"(ssr)/../../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\");\n    } catch (e) {\n    // ignore\n    }\n}\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */ function transformZipOutput(type, content, mimeType) {\n    switch(type){\n        case \"blob\":\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\":\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n    }\n}\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */ function concat(type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++){\n        totalLength += dataArray[i].length;\n    }\n    switch(type){\n        case \"string\":\n            return dataArray.join(\"\");\n        case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++){\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n    }\n}\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */ function accumulate(helper, updateCallback) {\n    return new external.Promise(function(resolve, reject) {\n        var dataArray = [];\n        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n        helper.on(\"data\", function(data, meta) {\n            dataArray.push(data);\n            if (updateCallback) {\n                updateCallback(meta);\n            }\n        }).on(\"error\", function(err) {\n            dataArray = [];\n            reject(err);\n        }).on(\"end\", function() {\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        }).resume();\n    });\n}\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */ function StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType){\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n            break;\n        case \"base64\":\n            internalType = \"string\";\n            break;\n    }\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch (e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */ accumulate: function(updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */ on: function(evt, fn) {\n        var self = this;\n        if (evt === \"data\") {\n            this._worker.on(evt, function(chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function() {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ resume: function() {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ pause: function() {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */ toNodejsStream: function(updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode: this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\nmodule.exports = StreamHelper;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNkRBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtRkFBaUI7QUFDN0MsSUFBSUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyxtRkFBaUI7QUFDN0MsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMsK0RBQVc7QUFDaEMsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsaUVBQVk7QUFDbEMsSUFBSUssV0FBV0wsbUJBQU9BLENBQUMsbUVBQWE7QUFFcEMsSUFBSU0sNEJBQTRCO0FBQ2hDLElBQUlGLFFBQVFHLFVBQVUsRUFBRTtJQUNwQixJQUFJO1FBQ0FELDRCQUE0Qk4sbUJBQU9BLENBQUMsbUhBQXFDO0lBQzdFLEVBQUUsT0FBTVEsR0FBRztJQUNQLFNBQVM7SUFDYjtBQUNKO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQyxtQkFBbUJDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQy9DLE9BQU9GO1FBQ1AsS0FBSztZQUNELE9BQU9YLE1BQU1jLE9BQU8sQ0FBQ2QsTUFBTWUsV0FBVyxDQUFDLGVBQWVILFVBQVVDO1FBQ3BFLEtBQUs7WUFDRCxPQUFPVCxPQUFPWSxNQUFNLENBQUNKO1FBQ3pCO1lBQ0ksT0FBT1osTUFBTWUsV0FBVyxDQUFDSixNQUFNQztJQUNuQztBQUNKO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0ssT0FBUU4sSUFBSSxFQUFFTyxTQUFTO0lBQzVCLElBQUlDLEdBQUdDLFFBQVEsR0FBR0MsTUFBTSxNQUFNQyxjQUFjO0lBQzVDLElBQUlILElBQUksR0FBR0EsSUFBSUQsVUFBVUssTUFBTSxFQUFFSixJQUFLO1FBQ2xDRyxlQUFlSixTQUFTLENBQUNDLEVBQUUsQ0FBQ0ksTUFBTTtJQUN0QztJQUNBLE9BQU9aO1FBQ1AsS0FBSztZQUNELE9B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QUNKLE9BQU87WUFDSCxJQUFJLENBQUNVLE9BQU8sQ0FBQ1osRUFBRSxDQUFDaUIsS0FBSztnQkFDakI1RCxNQUFNaUUsS0FBSyxDQUFDSixJQUFJSyxXQUFXSjtZQUMvQjtRQUNKO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7O0tBR0MsR0FDRGIsUUFBUztRQUNMakQsTUFBTWlFLEtBQUssQ0FBQyxJQUFJLENBQUNWLE9BQU8sQ0FBQ04sTUFBTSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUNNLE9BQU87UUFDakQsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7O0tBR0MsR0FDRFksT0FBUTtRQUNKLElBQUksQ0FBQ1osT0FBTyxDQUFDWSxLQUFLO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7S0FJQyxHQUNEQyxnQkFBaUIsU0FBVVQsUUFBUTtRQUMvQjNELE1BQU1zRCxZQUFZLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUNiLFdBQVcsS0FBSyxjQUFjO1lBQ25DLGlFQUFpRTtZQUNqRSxxREFBcUQ7WUFDckQsaUVBQWlFO1lBQ2pFLGVBQWU7WUFDZixNQUFNLElBQUlWLE1BQU0sSUFBSSxDQUFDVSxXQUFXLEdBQUc7UUFDdkM7UUFFQSxPQUFPLElBQUlsQywwQkFBMEIsSUFBSSxFQUFFO1lBQ3ZDOEQsWUFBYSxJQUFJLENBQUM1QixXQUFXLEtBQUs7UUFDdEMsR0FBR2tCO0lBQ1A7QUFDSjtBQUdBVyxPQUFPQyxPQUFPLEdBQUdyQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL1N0cmVhbUhlbHBlci5qcz8wNTczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgQ29udmVydFdvcmtlciA9IHJlcXVpcmUoXCIuL0NvbnZlcnRXb3JrZXJcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgYmFzZTY0ID0gcmVxdWlyZShcIi4uL2Jhc2U2NFwiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWxcIik7XG5cbnZhciBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gbnVsbDtcbmlmIChzdXBwb3J0Lm5vZGVzdHJlYW0pIHtcbiAgICB0cnkge1xuICAgICAgICBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyID0gcmVxdWlyZShcIi4uL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyXCIpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIGZpbmFsIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBkYXRhLiBJZiB0aGUgdXNlciB3YW50cyBhIEJsb2IgZm9yXG4gKiBleGFtcGxlLCBpdCdzIGVhc2llciB0byB3b3JrIHdpdGggYW4gVThpbnRBcnJheSBhbmQgZmluYWxseSBkbyB0aGVcbiAqIEFycmF5QnVmZmVyL0Jsb2IgY29udmVyc2lvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lIG9mIHRoZSBmaW5hbCB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ3xVaW50OEFycmF5fEJ1ZmZlcn0gY29udGVudCB0aGUgY29udGVudCB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBjb250ZW50LCBpZiBhcHBsaWNhYmxlLlxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSBjb250ZW50IGluIHRoZSByaWdodCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVppcE91dHB1dCh0eXBlLCBjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgIHJldHVybiB1dGlscy5uZXdCbG9iKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlidWZmZXJcIiwgY29udGVudCksIG1pbWVUeXBlKTtcbiAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICBkZWZhdWx0IDpcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKHR5cGUsIGNvbnRlbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBhcnJheSBvZiBkYXRhIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gZGF0YUFycmF5IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIGNodW5rcyB0byBjb25jYXRlbmF0ZVxuICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgY29uY2F0ZW5hdGVkIGRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFza2VkIHR5cGUgaXMgdW5zdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gY29uY2F0ICh0eXBlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgaSwgaW5kZXggPSAwLCByZXMgPSBudWxsLCB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgfVxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gZGF0YUFycmF5LmpvaW4oXCJcIik7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkYXRhQXJyYXkpO1xuICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgIHJlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgZGF0YUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGRhdGFBcnJheSk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uY2F0IDogdW5zdXBwb3J0ZWQgdHlwZSAnXCIgICsgdHlwZSArIFwiJ1wiKTtcbiAgICB9XG59XG5cbi8qKlxuICogTGlzdGVuIGEgU3RyZWFtSGVscGVyLCBhY2N1bXVsYXRlIGl0cyBjb250ZW50IGFuZCBjb25jYXRlbmF0ZSBpdCBpbnRvIGFcbiAqIGNvbXBsZXRlIGJsb2NrLlxuICogQHBhcmFtIHtTdHJlYW1IZWxwZXJ9IGhlbHBlciB0aGUgaGVscGVyIHRvIHVzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNhbGxiYWNrIGEgY2FsbGJhY2sgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLiBDYWxsZWRcbiAqIHdpdGggb25lIGFyZyA6XG4gKiAtIHRoZSBtZXRhZGF0YSBsaW5rZWQgdG8gdGhlIHVwZGF0ZSByZWNlaXZlZC5cbiAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgdGhlIGFjY3VtdWxhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShoZWxwZXIsIHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgIHZhciBjaHVua1R5cGUgPSBoZWxwZXIuX2ludGVybmFsVHlwZSxcbiAgICAgICAgICAgIHJlc3VsdFR5cGUgPSBoZWxwZXIuX291dHB1dFR5cGUsXG4gICAgICAgICAgICBtaW1lVHlwZSA9IGhlbHBlci5fbWltZVR5cGU7XG4gICAgICAgIGhlbHBlclxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmKHVwZGF0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhbGxiYWNrKG1ldGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciB0byBlYXNpbHkgdXNlIHdvcmtlcnMgb3V0c2lkZSBvZiBKU1ppcC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXb3JrZXJ9IHdvcmtlciB0aGUgd29ya2VyIHRvIHdyYXBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQgYnkgdGhlIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbUhlbHBlcih3b3JrZXIsIG91dHB1dFR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIGludGVybmFsVHlwZSA9IG91dHB1dFR5cGU7XG4gICAgc3dpdGNoKG91dHB1dFR5cGUpIHtcbiAgICBjYXNlIFwiYmxvYlwiOlxuICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInVpbnQ4YXJyYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICBpbnRlcm5hbFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyB0aGUgdHlwZSB1c2VkIGludGVybmFsbHlcbiAgICAgICAgdGhpcy5faW50ZXJuYWxUeXBlID0gaW50ZXJuYWxUeXBlO1xuICAgICAgICAvLyB0aGUgdHlwZSB1c2VkIHRvIG91dHB1dCByZXN1bHRzXG4gICAgICAgIHRoaXMuX291dHB1dFR5cGUgPSBvdXRwdXRUeXBlO1xuICAgICAgICAvLyB0aGUgbWltZSB0eXBlXG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gbWltZVR5cGU7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChpbnRlcm5hbFR5cGUpO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXIucGlwZShuZXcgQ29udmVydFdvcmtlcihpbnRlcm5hbFR5cGUpKTtcbiAgICAgICAgLy8gdGhlIGxhc3Qgd29ya2VycyBjYW4gYmUgcmV3aXJlZCB3aXRob3V0IGlzc3VlcyBidXQgd2UgbmVlZCB0b1xuICAgICAgICAvLyBwcmV2ZW50IGFueSB1cGRhdGVzIG9uIHByZXZpb3VzIHdvcmtlcnMuXG4gICAgICAgIHdvcmtlci5sb2NrKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgIHRoaXMuX3dvcmtlci5lcnJvcihlKTtcbiAgICB9XG59XG5cblN0cmVhbUhlbHBlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGEgU3RyZWFtSGVscGVyLCBhY2N1bXVsYXRlIGl0cyBjb250ZW50IGFuZCBjb25jYXRlbmF0ZSBpdCBpbnRvIGFcbiAgICAgKiBjb21wbGV0ZSBibG9jay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBmb3IgdGhlIGFjY3VtdWxhdGlvbi5cbiAgICAgKi9cbiAgICBhY2N1bXVsYXRlIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRlKHRoaXMsIHVwZGF0ZUNiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRyaWdnZXJlZCBvbiBhIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKGV2dCwgZm4pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmKGV2dCA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbihldnQsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoc2VsZiwgY2h1bmsuZGF0YSwgY2h1bmsubWV0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5vbihldnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5kZWxheShmbiwgYXJndW1lbnRzLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVzdW1lIHRoZSBmbG93IG9mIGNodW5rcy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICByZXN1bWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLmRlbGF5KHRoaXMuX3dvcmtlci5yZXN1bWUsIFtdLCB0aGlzLl93b3JrZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSBmbG93IG9mIGNodW5rcy5cbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBwYXVzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLnBhdXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbm9kZWpzIHN0cmVhbSBmb3IgdGhpcyBoZWxwZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHtOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyfSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0b05vZGVqc1N0cmVhbSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoXCJub2Rlc3RyZWFtXCIpO1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCBzdHJlYW0gY29udGFpbmluZyBibG9iL2FycmF5YnVmZmVyL3VpbnQ4YXJyYXkvc3RyaW5nXG4gICAgICAgICAgICAvLyBpcyBzdHJhbmdlIGFuZCBJIGRvbid0IGtub3cgaWYgaXQgd291bGQgYmUgdXNlZnVsLlxuICAgICAgICAgICAgLy8gSSB5b3UgZmluZCB0aGlzIGNvbW1lbnQgYW5kIGhhdmUgYSBnb29kIHVzZWNhc2UsIHBsZWFzZSBvcGVuIGFcbiAgICAgICAgICAgIC8vIGJ1ZyByZXBvcnQgIVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuX291dHB1dFR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbWV0aG9kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyKHRoaXMsIHtcbiAgICAgICAgICAgIG9iamVjdE1vZGUgOiB0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIlxuICAgICAgICB9LCB1cGRhdGVDYik7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUhlbHBlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJDb252ZXJ0V29ya2VyIiwiR2VuZXJpY1dvcmtlciIsImJhc2U2NCIsInN1cHBvcnQiLCJleHRlcm5hbCIsIk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIiLCJub2Rlc3RyZWFtIiwiZSIsInRyYW5zZm9ybVppcE91dHB1dCIsInR5cGUiLCJjb250ZW50IiwibWltZVR5cGUiLCJuZXdCbG9iIiwidHJhbnNmb3JtVG8iLCJlbmNvZGUiLCJjb25jYXQiLCJkYXRhQXJyYXkiLCJpIiwiaW5kZXgiLCJyZXMiLCJ0b3RhbExlbmd0aCIsImxlbmd0aCIsImpvaW4iLCJBcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwiVWludDhBcnJheSIsInNldCIsIkJ1ZmZlciIsIkVycm9yIiwiYWNjdW11bGF0ZSIsImhlbHBlciIsInVwZGF0ZUNhbGxiYWNrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjaHVua1R5cGUiLCJfaW50ZXJuYWxUeXBlIiwicmVzdWx0VHlwZSIsIl9vdXRwdXRUeXBlIiwiX21pbWVUeXBlIiwib24iLCJkYXRhIiwibWV0YSIsInB1c2giLCJlcnIiLCJyZXN1bHQiLCJyZXN1bWUiLCJTdHJlYW1IZWxwZXIiLCJ3b3JrZXIiLCJvdXRwdXRUeXBlIiwiaW50ZXJuYWxUeXBlIiwiY2hlY2tTdXBwb3J0IiwiX3dvcmtlciIsInBpcGUiLCJsb2NrIiwiZXJyb3IiLCJ1cGRhdGVDYiIsImV2dCIsImZuIiwic2VsZiIsImNodW5rIiwiY2FsbCIsImRlbGF5IiwiYXJndW1lbnRzIiwicGF1c2UiLCJ0b05vZGVqc1N0cmVhbSIsIm9iamVjdE1vZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/stream/StreamHelper.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/support.js":
/*!***********************************************!*\
  !*** ../../node_modules/jszip/lib/support.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n} else {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([\n            buffer\n        ], {\n            type: \"application/zip\"\n        }).size === 0;\n    } catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob(\"application/zip\").size === 0;\n        } catch (e) {\n            exports.blob = false;\n        }\n    }\n}\ntry {\n    exports.nodestream = !!(__webpack_require__(/*! readable-stream */ \"(ssr)/../../node_modules/readable-stream/readable.js\").Readable);\n} catch (e) {\n    exports.nodestream = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdXBwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLGNBQWMsR0FBRztBQUNqQkEsYUFBYSxHQUFHO0FBQ2hCQSxjQUFjLEdBQUc7QUFDakJBLG1CQUFtQixHQUFHLE9BQU9LLGdCQUFnQixlQUFlLE9BQU9DLGVBQWU7QUFDbEZOLGtCQUFrQixHQUFHLE9BQU9RLFdBQVc7QUFDdkMsd0VBQXdFO0FBQ3hFUixrQkFBa0IsR0FBRyxPQUFPTSxlQUFlO0FBRTNDLElBQUksT0FBT0QsZ0JBQWdCLGFBQWE7SUFDcENMLFlBQVksR0FBRztBQUNuQixPQUNLO0lBQ0QsSUFBSVcsU0FBUyxJQUFJTixZQUFZO0lBQzdCLElBQUk7UUFDQUwsWUFBWSxHQUFHLElBQUlZLEtBQUs7WUFBQ0Q7U0FBTyxFQUFFO1lBQzlCRSxNQUFNO1FBQ1YsR0FBR0MsSUFBSSxLQUFLO0lBQ2hCLEVBQ0EsT0FBT0MsR0FBRztRQUNOLElBQUk7WUFDQSxJQUFJQyxVQUFVQyxLQUFLQyxXQUFXLElBQUlELEtBQUtFLGlCQUFpQixJQUFJRixLQUFLRyxjQUFjLElBQUlILEtBQUtJLGFBQWE7WUFDckcsSUFBSUMsVUFBVSxJQUFJTjtZQUNsQk0sUUFBUUMsTUFBTSxDQUFDWjtZQUNmWCxZQUFZLEdBQUdzQixRQUFRRSxPQUFPLENBQUMsbUJBQW1CVixJQUFJLEtBQUs7UUFDL0QsRUFDQSxPQUFPQyxHQUFHO1lBQ05mLFlBQVksR0FBRztRQUNuQjtJQUNKO0FBQ0o7QUFFQSxJQUFJO0lBQ0FBLGtCQUFrQixHQUFHLENBQUMsQ0FBQzBCLDZHQUFtQztBQUM5RCxFQUFFLE9BQU1YLEdBQUc7SUFDUGYsa0JBQWtCLEdBQUc7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanM/MTY5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5iYXNlNjQgPSB0cnVlO1xuZXhwb3J0cy5hcnJheSA9IHRydWU7XG5leHBvcnRzLnN0cmluZyA9IHRydWU7XG5leHBvcnRzLmFycmF5YnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0cy5ub2RlYnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIGNvbnRhaW5zIHRydWUgaWYgSlNaaXAgY2FuIHJlYWQvZ2VuZXJhdGUgVWludDhBcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuZXhwb3J0cy51aW50OGFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5cbmlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbn1cbmVsc2Uge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhwb3J0cy5ibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vemlwXCJcbiAgICAgICAgfSkuc2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQoYnVmZmVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGJ1aWxkZXIuZ2V0QmxvYihcImFwcGxpY2F0aW9uL3ppcFwiKS5zaXplID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudHJ5IHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSAhIXJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIikuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYmFzZTY0IiwiYXJyYXkiLCJzdHJpbmciLCJhcnJheWJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiVWludDhBcnJheSIsIm5vZGVidWZmZXIiLCJCdWZmZXIiLCJ1aW50OGFycmF5IiwiYmxvYiIsImJ1ZmZlciIsIkJsb2IiLCJ0eXBlIiwic2l6ZSIsImUiLCJCdWlsZGVyIiwic2VsZiIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJidWlsZGVyIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIm5vZGVzdHJlYW0iLCJyZXF1aXJlIiwiUmVhZGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/support.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/utf8.js":
/*!********************************************!*\
  !*** ../../node_modules/jszip/lib/utf8.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/../../node_modules/jszip/lib/nodejsUtils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor(var i = 0; i < 256; i++){\n    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nvar string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n// convert array to string\nvar buf2string = function(buf) {\n    var i, out, c, c_len;\n    var len = buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if (utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n// That's all for the pako functions.\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */ exports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n    return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */ exports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n    return buf2string(buf);\n};\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */ function Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8DecodeWorker.prototype.processChunk = function(chunk) {\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if (support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n    this.push({\n        data: exports.utf8decode(usableData),\n        meta: chunk.meta\n    });\n};\n/**\n * @see GenericWorker.flush\n */ Utf8DecodeWorker.prototype.flush = function() {\n    if (this.leftOver && this.leftOver.length) {\n        this.push({\n            data: exports.utf8decode(this.leftOver),\n            meta: {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */ function Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8EncodeWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: exports.utf8encode(chunk.data),\n        meta: chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsNERBQVM7QUFDN0IsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMsZ0VBQVc7QUFDakMsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsd0VBQWU7QUFDekMsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQywwRkFBd0I7QUFFcEQ7OztDQUdDLEdBRUQsaUVBQWlFO0FBQ2pFLG9GQUFvRjtBQUNwRiw2Q0FBNkM7QUFDN0MsSUFBSUksV0FBVyxJQUFJQyxNQUFNO0FBQ3pCLElBQUssSUFBSUMsSUFBRSxHQUFHQSxJQUFFLEtBQUtBLElBQUs7SUFDdEJGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUk7QUFDOUY7QUFDQUYsUUFBUSxDQUFDLElBQUksR0FBQ0EsUUFBUSxDQUFDLElBQUksR0FBQyxHQUFHLHlCQUF5QjtBQUV4RCxpREFBaUQ7QUFDakQsSUFBSUcsYUFBYSxTQUFVQyxHQUFHO0lBQzFCLElBQUlDLEtBQUtDLEdBQUdDLElBQUlDLE9BQU9OLEdBQUdPLFVBQVVMLElBQUlNLE1BQU0sRUFBRUMsVUFBVTtJQUUxRCxvQkFBb0I7SUFDcEIsSUFBS0gsUUFBUSxHQUFHQSxRQUFRQyxTQUFTRCxRQUFTO1FBQ3RDRixJQUFJRixJQUFJUSxVQUFVLENBQUNKO1FBQ25CLElBQUksQ0FBQ0YsSUFBSSxNQUFLLE1BQU8sVUFBV0UsUUFBTSxJQUFJQyxTQUFVO1lBQ2hERixLQUFLSCxJQUFJUSxVQUFVLENBQUNKLFFBQU07WUFDMUIsSUFBSSxDQUFDRCxLQUFLLE1BQUssTUFBTyxRQUFRO2dCQUMxQkQsSUFBSSxVQUFXLEtBQUssVUFBVyxFQUFDLElBQU1DLENBQUFBLEtBQUssTUFBSztn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QUFDUSxJQUFJLENBQUM7UUFDTlAsTUFBT2QsUUFBUUMsVUFBVSxDQUFDWSxNQUFNQyxJQUFJO1FBQ3BDUSxNQUFPVCxNQUFNUyxJQUFJO0lBQ3JCO0FBQ0o7QUFDQXRCLHdCQUF3QixHQUFHd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanM/N2U2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvdXRpbHMvc3RyaW5nc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGk9MDsgaTwyNTY7IGkrKykge1xuICAgIF91dGY4bGVuW2ldID0gKGkgPj0gMjUyID8gNiA6IGkgPj0gMjQ4ID8gNSA6IGkgPj0gMjQwID8gNCA6IGkgPj0gMjI0ID8gMyA6IGkgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XT1fdXRmOGxlblsyNTRdPTE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICAgIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICAgIH1cblxuICAgIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gbmV3IEFycmF5KGJ1Zl9sZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnRcbiAgICBmb3IgKGk9MCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG52YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uKGJ1ZiwgbWF4KSB7XG4gICAgdmFyIHBvcztcblxuICAgIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAgIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICAgIHBvcyA9IG1heC0xO1xuICAgIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gICAgLy8gRnVja3VwIC0gdmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAgIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyB2dWZmZXIgaXMgdG9vIHNtYWxsLFxuICAgIC8vIHJldHVybiBtYXggdG9vLlxuICAgIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAgIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAgIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbioyKTtcblxuICAgIGZvciAob3V0PTAsIGk9MDsgaTxsZW47KSB7XG4gICAgICAgIGMgPSBidWZbaSsrXTtcbiAgICAgICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgICAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgICAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICAgICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4tMTsgY29udGludWU7IH1cblxuICAgICAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgICAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICAgICAgICBjX2xlbi0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgICAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgICAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjIC09IDB4MTAwMDA7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaHJpbmtCdWYodXRmMTZidWYsIG91dClcbiAgICBpZiAodXRmMTZidWYubGVuZ3RoICE9PSBvdXQpIHtcbiAgICAgICAgaWYodXRmMTZidWYuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmID0gdXRmMTZidWYuc3ViYXJyYXkoMCwgb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmLmxlbmd0aCA9IG91dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0ZjE2YnVmKTtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlGcm9tQ2hhckNvZGUodXRmMTZidWYpO1xufTtcblxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBqYXZhc2NyaXB0IHN0cmluZyBpbnRvIGFuIGFycmF5ICh0eXBlZCBpZiBwb3NzaWJsZSkgb2YgYnl0ZXMsXG4gKiBVVEYtOCBlbmNvZGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZW5jb2RlID0gZnVuY3Rpb24gdXRmOGVuY29kZShzdHIpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKHN0ciwgXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nMmJ1ZihzdHIpO1xufTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGJ5dGVzIGFycmF5IChvciBhIHJlcHJlc2VudGF0aW9uKSByZXByZXNlbnRpbmcgYW4gVVRGLTggZW5jb2RlZFxuICogc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IGJ1ZiB0aGUgZGF0YSBkZSBkZWNvZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhkZWNvZGUgPSBmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ1Zikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwibm9kZWJ1ZmZlclwiLCBidWYpLnRvU3RyaW5nKFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgYnVmID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGJ1Zik7XG5cbiAgICByZXR1cm4gYnVmMnN0cmluZyhidWYpO1xufTtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBkZWNvZGUgdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MgaW50byBzdHJpbmcgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhEZWNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZGVjb2RlXCIpO1xuICAgIC8vIHRoZSBsYXN0IGJ5dGVzIGlmIGEgY2h1bmsgZGlkbid0IGVuZCB3aXRoIGEgY29tcGxldGUgY29kZXBvaW50LlxuICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOERlY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIHZhciBkYXRhID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGNodW5rLmRhdGEpO1xuXG4gICAgLy8gMXN0IHN0ZXAsIHJlLXVzZSB3aGF0J3MgbGVmdCBvZiB0aGUgcHJldmlvdXMgY2h1bmtcbiAgICBpZiAodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICBpZihzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHByZXZpb3VzRGF0YS5sZW5ndGggKyB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgICAgICBkYXRhLnNldCh0aGlzLmxlZnRPdmVyLCAwKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHByZXZpb3VzRGF0YSwgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMubGVmdE92ZXIuY29uY2F0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBuZXh0Qm91bmRhcnkgPSB1dGY4Ym9yZGVyKGRhdGEpO1xuICAgIHZhciB1c2FibGVEYXRhID0gZGF0YTtcbiAgICBpZiAobmV4dEJvdW5kYXJ5ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zdWJhcnJheSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc3ViYXJyYXkobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2FibGVEYXRhID0gZGF0YS5zbGljZSgwLCBuZXh0Qm91bmRhcnkpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IGRhdGEuc2xpY2UobmV4dEJvdW5kYXJ5LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHVzYWJsZURhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh0aGlzLmxlZnRPdmVyKSxcbiAgICAgICAgICAgIG1ldGEgOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxufTtcbmV4cG9ydHMuVXRmOERlY29kZVdvcmtlciA9IFV0ZjhEZWNvZGVXb3JrZXI7XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZW5kY29kZSBzdHJpbmcgY2h1bmtzIGludG8gdXRmOCBlbmNvZGVkIGJpbmFyeSBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOEVuY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBlbmNvZGVcIik7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RW5jb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhFbmNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhlbmNvZGUoY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuZXhwb3J0cy5VdGY4RW5jb2RlV29ya2VyID0gVXRmOEVuY29kZVdvcmtlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJzdXBwb3J0Iiwibm9kZWpzVXRpbHMiLCJHZW5lcmljV29ya2VyIiwiX3V0ZjhsZW4iLCJBcnJheSIsImkiLCJzdHJpbmcyYnVmIiwic3RyIiwiYnVmIiwiYyIsImMyIiwibV9wb3MiLCJzdHJfbGVuIiwibGVuZ3RoIiwiYnVmX2xlbiIsImNoYXJDb2RlQXQiLCJ1aW50OGFycmF5IiwiVWludDhBcnJheSIsInV0Zjhib3JkZXIiLCJtYXgiLCJwb3MiLCJidWYyc3RyaW5nIiwib3V0IiwiY19sZW4iLCJsZW4iLCJ1dGYxNmJ1ZiIsInN1YmFycmF5IiwiYXBwbHlGcm9tQ2hhckNvZGUiLCJleHBvcnRzIiwidXRmOGVuY29kZSIsIm5vZGVidWZmZXIiLCJuZXdCdWZmZXJGcm9tIiwidXRmOGRlY29kZSIsInRyYW5zZm9ybVRvIiwidG9TdHJpbmciLCJVdGY4RGVjb2RlV29ya2VyIiwiY2FsbCIsImxlZnRPdmVyIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJwcm9jZXNzQ2h1bmsiLCJjaHVuayIsImRhdGEiLCJwcmV2aW91c0RhdGEiLCJzZXQiLCJjb25jYXQiLCJuZXh0Qm91bmRhcnkiLCJ1c2FibGVEYXRhIiwic2xpY2UiLCJwdXNoIiwibWV0YSIsImZsdXNoIiwiVXRmOEVuY29kZVdvcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/utf8.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/utils.js":
/*!*********************************************!*\
  !*** ../../node_modules/jszip/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"(ssr)/../../node_modules/jszip/lib/base64.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/../../node_modules/jszip/lib/nodejsUtils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/../../node_modules/jszip/lib/external.js\");\n__webpack_require__(/*! setimmediate */ \"(ssr)/../../node_modules/next/dist/compiled/setimmediate/setImmediate.js\");\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */ function string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n        result = new Uint8Array(str.length);\n    } else {\n        result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */ exports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n    try {\n        // Blob constructor\n        return new Blob([\n            part\n        ], {\n            type: type\n        });\n    } catch (e) {\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        } catch (e) {\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */ function identity(input) {\n    return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */ function stringToArrayLike(str, array) {\n    for(var i = 0; i < str.length; ++i){\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */ var arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */ stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while(k < len){\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            } else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */ stringifyByChar: function(array) {\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++){\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed: {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */ uint8array: function() {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */ nodebuffer: function() {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }()\n    }\n};\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */ function arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n    if (canUseApply) {\n        while(chunk > 1){\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */ function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for(var i = 0; i < arrayFrom.length; i++){\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return new Uint8Array(input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */ exports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n/**\n * Resolve all relative path components, \".\" and \"..\", in a path. If these relative components\n * traverse above the root then the resulting path will only contain the final path component.\n *\n * All empty components, e.g. \"//\", are removed.\n * @param {string} path A path with / or \\ separators\n * @returns {string} The path with all relative path components resolved.\n */ exports.resolve = function(path) {\n    var parts = path.split(\"/\");\n    var result = [];\n    for(var index = 0; index < parts.length; index++){\n        var part = parts[index];\n        // Allow the first and last component to be empty for trailing slashes.\n        if (part === \".\" || part === \"\" && index !== 0 && index !== parts.length - 1) {\n            continue;\n        } else if (part === \"..\") {\n            result.pop();\n        } else {\n            result.push(part);\n        }\n    }\n    return result.join(\"/\");\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */ exports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */ exports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */ exports.pretty = function(str) {\n    var res = \"\", code, i;\n    for(i = 0; i < (str || \"\").length; i++){\n        code = str.charCodeAt(i);\n        res += \"\\\\x\" + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */ exports.delay = function(callback, args, self1) {\n    setImmediate(function() {\n        callback.apply(self1 || null, args || []);\n    });\n};\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */ exports.inherits = function(ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */ exports.extend = function() {\n    var result = {}, i, attr;\n    for(i = 0; i < arguments.length; i++){\n        for(attr in arguments[i]){\n            if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */ exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        var isBlob = support.blob && (data instanceof Blob || [\n            \"[object File]\",\n            \"[object Blob]\"\n        ].indexOf(Object.prototype.toString.call(data)) !== -1);\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function(resolve, reject) {\n                var reader = new FileReader();\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n        if (!dataType) {\n            return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            } else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDLGdFQUFXO0FBQ2pDLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDLDhEQUFVO0FBQy9CLElBQUlFLGNBQWNGLG1CQUFPQSxDQUFDLHdFQUFlO0FBQ3pDLElBQUlHLFdBQVdILG1CQUFPQSxDQUFDLGtFQUFZO0FBQ25DQSxtQkFBT0EsQ0FBQyw4RkFBYztBQUd0Qjs7Ozs7O0NBTUMsR0FDRCxTQUFTSSxjQUFjQyxHQUFHO0lBQ3RCLElBQUlDLFNBQVM7SUFDYixJQUFJUCxRQUFRUSxVQUFVLEVBQUU7UUFDcEJELFNBQVMsSUFBSUUsV0FBV0gsSUFBSUksTUFBTTtJQUN0QyxPQUFPO1FBQ0hILFNBQVMsSUFBSUksTUFBTUwsSUFBSUksTUFBTTtJQUNqQztJQUNBLE9BQU9FLGtCQUFrQk4sS0FBS0M7QUFDbEM7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRE0sZUFBZSxHQUFHLFNBQVNFLElBQUksRUFBRUMsSUFBSTtJQUNqQ0gsUUFBUUksWUFBWSxDQUFDO0lBRXJCLElBQUk7UUFDQSxtQkFBbUI7UUFDbkIsT0FBTyxJQUFJQyxLQUFLO1lBQUNIO1NBQUssRUFBRTtZQUNwQkMsTUFBTUE7UUFDVjtJQUNKLEVBQ0EsT0FBT0csR0FBRztRQUVOLElBQUk7WUFDQSxvQ0FBb0M7WUFDcEMsSUFBSUMsVUFBVUMsS0FBS0MsV0FBVyxJQUFJRCxLQUFLRSxpQkFBaUIsSUFBSUYsS0FBS0csY0FBYyxJQUFJSCxLQUFLSSxhQUFhO1lBQ3JHLElBQUlDLFVBQVUsSUFBSU47WUFDbEJNLFFBQVFDLE1BQU0sQ0FBQ1o7WUFDZixPQUFPVyxRQUFRRSxPQUFPLENBQUNaO1FBQzNCLEVBQ0EsT0FBT0csR0FBRztZQUVOLGdCQUFnQjtZQUNoQixNQUFNLElBQUlVLE1BQU07UUFDcEI7SUFDSjtBQUdKO0FBQ0E7Ozs7Q0FJQyxHQUNE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T0FBT0csZUFBZSxhQUFhO1lBQzdDLE9BQU8sSUFBSS9HLFNBQVN5RyxPQUFPLENBQUMsU0FBVXhDLE9BQU8sRUFBRStDLE1BQU07Z0JBQ2pELElBQUlDLFNBQVMsSUFBSUY7Z0JBRWpCRSxPQUFPQyxNQUFNLEdBQUcsU0FBU25HLENBQUM7b0JBQ3RCa0QsUUFBUWxELEVBQUVvRyxNQUFNLENBQUNoSCxNQUFNO2dCQUMzQjtnQkFDQThHLE9BQU9HLE9BQU8sR0FBRyxTQUFTckcsQ0FBQztvQkFDdkJpRyxPQUFPakcsRUFBRW9HLE1BQU0sQ0FBQ0UsS0FBSztnQkFDekI7Z0JBQ0FKLE9BQU9LLGlCQUFpQixDQUFDWDtZQUM3QjtRQUNKLE9BQU87WUFDSCxPQUFPQTtRQUNYO0lBQ0o7SUFFQSxPQUFPSCxRQUFRRSxJQUFJLENBQUMsU0FBU0MsSUFBSTtRQUM3QixJQUFJWSxXQUFXOUcsUUFBUTBDLFNBQVMsQ0FBQ3dEO1FBRWpDLElBQUksQ0FBQ1ksVUFBVTtZQUNYLE9BQU92SCxTQUFTeUcsT0FBTyxDQUFDTyxNQUFNLENBQzFCLElBQUl2RixNQUFNLDZCQUE2QjBFLE9BQU8sY0FDcEM7UUFFbEI7UUFDQSwrRUFBK0U7UUFDL0UsSUFBSW9CLGFBQWEsZUFBZTtZQUM1QlosT0FBT2xHLFFBQVFxRCxXQUFXLENBQUMsY0FBYzZDO1FBQzdDLE9BQU8sSUFBSVksYUFBYSxVQUFVO1lBQzlCLElBQUloQixVQUFVO2dCQUNWSSxPQUFPN0csT0FBTzBILE1BQU0sQ0FBQ2I7WUFDekIsT0FDSyxJQUFJTixVQUFVO2dCQUNmLGdHQUFnRztnQkFDaEcsSUFBSUMsNEJBQTRCLE1BQU07b0JBQ2xDLDRDQUE0QztvQkFDNUMsaURBQWlEO29CQUNqREssT0FBTzFHLGNBQWMwRztnQkFDekI7WUFDSjtRQUNKO1FBQ0EsT0FBT0E7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGphcnZpcy93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi91dGlscy5qcz8zMWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG52YXIgYmFzZTY0ID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRoYXQgcGFzcyBhcyBhIFwiYmluYXJ5IHN0cmluZ1wiOiBpdCBzaG91bGQgcmVwcmVzZW50IGEgYnl0ZVxuICogYXJyYXkgYnV0IG1heSBoYXZlID4gMjU1IGNoYXIgY29kZXMuIEJlIHN1cmUgdG8gdGFrZSBvbmx5IHRoZSBmaXJzdCBieXRlXG4gKiBhbmQgcmV0dXJucyB0aGUgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fSB0aGUgc3RyaW5nIGluIGEgYmluYXJ5IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJpbmFyeShzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9uIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgYWxsIHJlbGF0aXZlIHBhdGggY29tcG9uZW50cywgXCIuXCIgYW5kIFwiLi5cIiwgaW4gYSBwYXRoLiBJZiB0aGVzZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gKiB0cmF2ZXJzZSBhYm92ZSB0aGUgcm9vdCB0aGVuIHRoZSByZXN1bHRpbmcgcGF0aCB3aWxsIG9ubHkgY29udGFpbiB0aGUgZmluYWwgcGF0aCBjb21wb25lbnQuXG4gKlxuICogQWxsIGVtcHR5IGNvbXBvbmVudHMsIGUuZy4gXCIvL1wiLCBhcmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEEgcGF0aCB3aXRoIC8gb3IgXFwgc2VwYXJhdG9yc1xuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggd2l0aCBhbGwgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzIHJlc29sdmVkLlxuICovXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgIC8vIEFsbG93IHRoZSBmaXJzdCBhbmQgbGFzdCBjb21wb25lbnQgdG8gYmUgZW1wdHkgZm9yIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgICAgIGlmIChwYXJ0ID09PSBcIi5cIiB8fCAocGFydCA9PT0gXCJcIiAmJiBpbmRleCAhPT0gMCAmJiBpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiL1wiKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIFRoZSB0eXBlIHdpbGwgYmUgaW4gYSBmb3JtYXQgdmFsaWQgZm9yIEpTWmlwLnV0aWxzLnRyYW5zZm9ybVRvIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0IHRvIGlkZW50aWZ5LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgKGxvd2VyY2FzZSkgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydHMuZ2V0VHlwZU9mID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIgJiYgbm9kZWpzVXRpbHMuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcIm5vZGVidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSAmJiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDhhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5hcnJheWJ1ZmZlciAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHR5cGUuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0W3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxufTtcblxuZXhwb3J0cy5NQVhfVkFMVUVfMTZCSVRTID0gNjU1MzU7XG5leHBvcnRzLk1BWF9WQUxVRV8zMkJJVFMgPSAtMTsgLy8gd2VsbCwgXCJcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXCIgaXMgcGFyc2VkIGFzIC0xXG5cbi8qKlxuICogUHJldHRpZnkgYSBzdHJpbmcgcmVhZCBhcyBiaW5hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gcHJldHRpZnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgcHJldHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgcmVzID0gXCJcIixcbiAgICAgICAgY29kZSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgKHN0ciB8fCBcIlwiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJlcyArPSBcIlxcXFx4XCIgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwgYXR0cikgJiYgdHlwZW9mIHJlc3VsdFthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthdHRyXSA9IGFyZ3VtZW50c1tpXVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYXJiaXRyYXJ5IGNvbnRlbnQgaW50byBhIFByb21pc2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG5hbWUgZm9yIHRoZSBjb250ZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGEgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgdHJ1ZSBpZiB0aGUgY29udGVudCBpcyBub3QgYW4gdW5pY29kZSBzdHJpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgb25seSBoYXMgb25lIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCYXNlNjQgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRlbnQgaXMgZW5jb2RlZCB3aXRoIGJhc2U2NC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSBpbiBhIGZvcm1hdCB1c2FibGUgYnkgSlNaaXAuXG4gKi9cbmV4cG9ydHMucHJlcGFyZUNvbnRlbnQgPSBmdW5jdGlvbihuYW1lLCBpbnB1dERhdGEsIGlzQmluYXJ5LCBpc09wdGltaXplZEJpbmFyeVN0cmluZywgaXNCYXNlNjQpIHtcblxuICAgIC8vIGlmIGlucHV0RGF0YSBpcyBhbHJlYWR5IGEgcHJvbWlzZSwgdGhpcyBmbGF0dGVuIGl0LlxuICAgIHZhciBwcm9taXNlID0gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKGlucHV0RGF0YSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG5cblxuICAgICAgICB2YXIgaXNCbG9iID0gc3VwcG9ydC5ibG9iICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBbXCJbb2JqZWN0IEZpbGVdXCIsIFwiW29iamVjdCBCbG9iXVwiXS5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkgIT09IC0xKTtcblxuICAgICAgICBpZiAoaXNCbG9iICYmIHR5cGVvZiBGaWxlUmVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoZGF0YSk7XG5cbiAgICAgICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNhbid0IHJlYWQgdGhlIGRhdGEgb2YgJ1wiICsgbmFtZSArIFwiJy4gSXMgaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImluIGEgc3VwcG9ydGVkIEphdmFTY3JpcHQgdHlwZSAoU3RyaW5nLCBCbG9iLCBBcnJheUJ1ZmZlciwgZXRjKSA/XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSA6IGl0J3Mgd2F5IGVhc2llciB0byB3b3JrIHdpdGggVWludDhBcnJheSB0aGFuIHdpdGggQXJyYXlCdWZmZXJcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBleHBvcnRzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzQmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZEJpbmFyeVN0cmluZyA9PT0gdHJ1ZSBtZWFucyB0aGF0IHRoZSBmaWxlIGhhcyBhbHJlYWR5IGJlZW4gZmlsdGVyZWQgd2l0aCBhIDB4RkYgbWFza1xuICAgICAgICAgICAgICAgIGlmIChpc09wdGltaXplZEJpbmFyeVN0cmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3RyaW5nLCBub3QgaW4gYSBiYXNlNjQgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCZSBzdXJlIHRoYXQgdGhpcyBpcyBhIGNvcnJlY3QgXCJiaW5hcnkgc3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHN0cmluZzJiaW5hcnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJzdXBwb3J0IiwicmVxdWlyZSIsImJhc2U2NCIsIm5vZGVqc1V0aWxzIiwiZXh0ZXJuYWwiLCJzdHJpbmcyYmluYXJ5Iiwic3RyIiwicmVzdWx0IiwidWludDhhcnJheSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJBcnJheSIsInN0cmluZ1RvQXJyYXlMaWtlIiwiZXhwb3J0cyIsIm5ld0Jsb2IiLCJwYXJ0IiwidHlwZSIsImNoZWNrU3VwcG9ydCIsIkJsb2IiLCJlIiwiQnVpbGRlciIsInNlbGYiLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiYnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJFcnJvciIsImlkZW50aXR5IiwiaW5wdXQiLCJhcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiYXJyYXlUb1N0cmluZ0hlbHBlciIsInN0cmluZ2lmeUJ5Q2h1bmsiLCJjaHVuayIsImsiLCJsZW4iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInB1c2giLCJzbGljZSIsIk1hdGgiLCJtaW4iLCJzdWJhcnJheSIsImpvaW4iLCJzdHJpbmdpZnlCeUNoYXIiLCJyZXN1bHRTdHIiLCJhcHBseUNhbkJlVXNlZCIsIm5vZGVidWZmZXIiLCJhbGxvY0J1ZmZlciIsImFycmF5TGlrZVRvU3RyaW5nIiwiZ2V0VHlwZU9mIiwiY2FuVXNlQXBwbHkiLCJmbG9vciIsImFwcGx5RnJvbUNoYXJDb2RlIiwiYXJyYXlMaWtlVG9BcnJheUxpa2UiLCJhcnJheUZyb20iLCJhcnJheVRvIiwidHJhbnNmb3JtIiwiYnVmZmVyIiwibmV3QnVmZmVyRnJvbSIsImJ5dGVMZW5ndGgiLCJ0cmFuc2Zvcm1UbyIsIm91dHB1dFR5cGUiLCJpbnB1dFR5cGUiLCJyZXNvbHZlIiwicGF0aCIsInBhcnRzIiwic3BsaXQiLCJpbmRleCIsInBvcCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzQnVmZmVyIiwiYXJyYXlidWZmZXIiLCJBcnJheUJ1ZmZlciIsInN1cHBvcnRlZCIsInRvTG93ZXJDYXNlIiwiTUFYX1ZBTFVFXzE2QklUUyIsIk1BWF9WQUxVRV8zMkJJVFMiLCJwcmV0dHkiLCJyZXMiLCJjb2RlIiwidG9VcHBlckNhc2UiLCJkZWxheSIsImNhbGxiYWNrIiwiYXJncyIsInNldEltbWVkaWF0ZSIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsIk9iaiIsImV4dGVuZCIsImF0dHIiLCJhcmd1bWVudHMiLCJoYXNPd25Qcm9wZXJ0eSIsInByZXBhcmVDb250ZW50IiwibmFtZSIsImlucHV0RGF0YSIsImlzQmluYXJ5IiwiaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmciLCJpc0Jhc2U2NCIsInByb21pc2UiLCJQcm9taXNlIiwidGhlbiIsImRhdGEiLCJpc0Jsb2IiLCJibG9iIiwiaW5kZXhPZiIsIkZpbGVSZWFkZXIiLCJyZWplY3QiLCJyZWFkZXIiLCJvbmxvYWQiLCJ0YXJnZXQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImRhdGFUeXBlIiwiZGVjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/zipEntries.js":
/*!**************************************************!*\
  !*** ../../node_modules/jszip/lib/zipEntries.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/../../node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"(ssr)/../../node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"(ssr)/../../node_modules/jszip/lib/zipEntry.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */ checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */ isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */ readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */ readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n        while(index < extraDataSize){\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */ readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */ readLocalFiles: function() {\n        var i, file;\n        for(i = 0; i < this.files.length; i++){\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */ readCentralDir: function() {\n        var file;\n        this.reader.setIndex(this.centralDirOffset);\n        while(this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)){\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n            // We found some records but not all.\n            // Something is wrong but we got something for the user: no error here.\n            // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */ readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" + \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */ if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */ // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */  + this.zip64EndOfCentralSize;\n        }\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n            // The offsets seem wrong, but we have something at the specified offset.\n            // So we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */ load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsbUJBQU9BLENBQUMsa0ZBQW9CO0FBQzVDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLDREQUFTO0FBQzdCLElBQUlFLE1BQU1GLG1CQUFPQSxDQUFDLG9FQUFhO0FBQy9CLElBQUlHLFdBQVdILG1CQUFPQSxDQUFDLGtFQUFZO0FBQ25DLElBQUlJLFVBQVVKLG1CQUFPQSxDQUFDLGdFQUFXO0FBQ2pDLHdCQUF3QjtBQUN4Qjs7OztDQUlDLEdBQ0QsU0FBU0ssV0FBV0MsV0FBVztJQUMzQixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQ2YsSUFBSSxDQUFDRCxXQUFXLEdBQUdBO0FBQ3ZCO0FBQ0FELFdBQVdHLFNBQVMsR0FBRztJQUNuQjs7OztLQUlDLEdBQ0RDLGdCQUFnQixTQUFTQyxpQkFBaUI7UUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxxQkFBcUIsQ0FBQ0Ysb0JBQW9CO1lBQ3ZELElBQUksQ0FBQ0MsTUFBTSxDQUFDRSxLQUFLLElBQUk7WUFDckIsSUFBSUMsWUFBWSxJQUFJLENBQUNILE1BQU0sQ0FBQ0ksVUFBVSxDQUFDO1lBQ3ZDLE1BQU0sSUFBSUMsTUFBTSxnREFBZ0QsTUFBTWYsTUFBTWdCLE1BQU0sQ0FBQ0gsYUFBYSxnQkFBZ0JiLE1BQU1nQixNQUFNLENBQUNQLHFCQUFxQjtRQUN0SjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRFEsYUFBYSxTQUFTQyxVQUFVLEVBQUVULGlCQUFpQjtRQUMvQyxJQUFJVSxlQUFlLElBQUksQ0FBQ1QsTUFBTSxDQUFDRSxLQUFLO1FBQ3BDLElBQUksQ0FBQ0YsTUFBTSxDQUFDVSxRQUFRLENBQUNGO1FBQ3JCLElBQUlMLFlBQVksSUFBSSxDQUFDSCxNQUFNLENBQUNJLFVBQVUsQ0FBQztRQUN2QyxJQUFJTyxTQUFTUixjQUFjSjtRQUMz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SUFBSSxnQ0FBZ0M7WUFDckVBLGlDQUFpQyxHQUFHLDJDQUEyQyxNQUFLLElBQUksQ0FBQ3JDLHFCQUFxQjtRQUNsSDtRQUVBLElBQUlzQyxhQUFhTix3QkFBd0JLO1FBRXpDLElBQUlDLGFBQWEsR0FBRztZQUNoQiwwRUFBMEU7WUFDMUUsSUFBSSxJQUFJLENBQUM1RCxXQUFXLENBQUNzRCx1QkFBdUJ0RSxJQUFJNkQsbUJBQW1CLEdBQUc7WUFDbEUseUVBQXlFO1lBQ3pFLGtCQUFrQjtZQUN0QixPQUFPO2dCQUNILHVEQUF1RDtnQkFDdkQsa0VBQWtFO2dCQUNsRSxJQUFJLENBQUNwRCxNQUFNLENBQUNvRSxJQUFJLEdBQUdEO1lBQ3ZCO1FBQ0osT0FBTyxJQUFJQSxhQUFhLEdBQUc7WUFDdkIsTUFBTSxJQUFJOUQsTUFBTSw0QkFBNEJnRSxLQUFLQyxHQUFHLENBQUNILGNBQWM7UUFDdkU7SUFDSjtJQUNBSSxlQUFlLFNBQVNDLElBQUk7UUFDeEIsSUFBSSxDQUFDeEUsTUFBTSxHQUFHWixVQUFVb0Y7SUFDNUI7SUFDQTs7O0tBR0MsR0FDREMsTUFBTSxTQUFTRCxJQUFJO1FBQ2YsSUFBSSxDQUFDRCxhQUFhLENBQUNDO1FBQ25CLElBQUksQ0FBQ2hCLGdCQUFnQjtRQUNyQixJQUFJLENBQUNMLGNBQWM7UUFDbkIsSUFBSSxDQUFDUixjQUFjO0lBQ3ZCO0FBQ0o7QUFDQSx3QkFBd0I7QUFDeEIrQixPQUFPQyxPQUFPLEdBQUdqRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqYXJ2aXMvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cmllcy5qcz85NzkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJlYWRlckZvciA9IHJlcXVpcmUoXCIuL3JlYWRlci9yZWFkZXJGb3JcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBzaWcgPSByZXF1aXJlKFwiLi9zaWduYXR1cmVcIik7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKFwiLi96aXBFbnRyeVwiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbi8vICBjbGFzcyBaaXBFbnRyaWVzIHt7e1xuLyoqXG4gKiBBbGwgdGhlIGVudHJpZXMgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyaWVzKGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5maWxlcyA9IFtdO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJpZXMucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHJlYWRlciBpcyBvbiB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIGV4cGVjdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgYW4gb3RoZXIgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGNoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbihleHBlY3RlZFNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShleHBlY3RlZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSBcIiArIFwiKFwiICsgdXRpbHMucHJldHR5KHNpZ25hdHVyZSkgKyBcIiwgZXhwZWN0ZWQgXCIgKyB1dGlscy5wcmV0dHkoZXhwZWN0ZWRTaWduYXR1cmUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGlzIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXNrZWRJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBzaWduYXR1cmUgdG8gZXhwZWN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBoZXJlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNTaWduYXR1cmU6IGZ1bmN0aW9uKGFza2VkSW5kZXgsIGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoYXNrZWRJbmRleCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2lnbmF0dXJlID09PSBleHBlY3RlZFNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZEJsb2NrRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIHRoaXMuemlwQ29tbWVudExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIC8vIHdhcm5pbmcgOiB0aGUgZW5jb2RpbmcgZGVwZW5kcyBvZiB0aGUgc3lzdGVtIGxvY2FsZVxuICAgICAgICAvLyBPbiBhIGxpbnV4IG1hY2hpbmUgd2l0aCBMQU5HPWVuX1VTLnV0ZjgsIHRoaXMgZmllbGQgaXMgdXRmOCBlbmNvZGVkLlxuICAgICAgICAvLyBPbiBhIHdpbmRvd3MgbWFjaGluZSwgdGhpcyBmaWVsZCBpcyBlbmNvZGVkIHdpdGggdGhlIGxvY2FsaXplZCB3aW5kb3dzIGNvZGUgcGFnZS5cbiAgICAgICAgdmFyIHppcENvbW1lbnQgPSB0aGlzLnJlYWRlci5yZWFkRGF0YSh0aGlzLnppcENvbW1lbnRMZW5ndGgpO1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIC8vIFRvIGdldCBjb25zaXN0ZW50IGJlaGF2aW9yIHdpdGggdGhlIGdlbmVyYXRpb24gcGFydCwgd2Ugd2lsbCBhc3N1bWUgdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIHV0ZjggZW5jb2RlZCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIGRlY29kZUNvbnRlbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHppcENvbW1lbnQpO1xuICAgICAgICB0aGlzLnppcENvbW1lbnQgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGRlY29kZUNvbnRlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICogTm90IG1lcmdlZCB3aXRoIHRoZSBtZXRob2QgcmVhZEVuZE9mQ2VudHJhbCA6XG4gICAgICogVGhlIGVuZCBvZiBjZW50cmFsIGNhbiBjb2V4aXN0IHdpdGggaXRzIFppcDY0IGJyb3RoZXIsXG4gICAgICogSSBkb24ndCB3YW50IHRvIHJlYWQgdGhlIHdyb25nIG51bWJlciBvZiBieXRlcyAhXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMucmVhZGVyLnNraXAoNCk7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk1hZGVCeSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHMgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcblxuICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGV4dHJhRGF0YVNpemUgPSB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZSAtIDQ0LFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZXh0cmFEYXRhU2l6ZSkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gdGhpcy5yZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yLlxuICAgICAqL1xuICAgIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIGlmICh0aGlzLmRpc2tzQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aS12b2x1bWVzIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgZmlsZXMsIGJhc2VkIG9uIHRoZSBvZmZzZXQgcmVhZCBpbiB0aGUgY2VudHJhbCBwYXJ0LlxuICAgICAqL1xuICAgIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGZpbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KGZpbGUubG9jYWxIZWFkZXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuICAgICAgICAgICAgZmlsZS5yZWFkTG9jYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIGZpbGUuaGFuZGxlVVRGOCgpO1xuICAgICAgICAgICAgZmlsZS5wcm9jZXNzQXR0cmlidXRlcygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWxlO1xuXG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpKSB7XG4gICAgICAgICAgICBmaWxlID0gbmV3IFppcEVudHJ5KHtcbiAgICAgICAgICAgICAgICB6aXA2NDogdGhpcy56aXA2NFxuICAgICAgICAgICAgfSwgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICBmaWxlLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSAwICYmIHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZXhwZWN0ZWQgc29tZSByZWNvcmRzIGJ1dCBjb3VsZG4ndCBmaW5kIEFOWS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlYWxseSBzdXNwaWNpb3VzLCBhcyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBzb21lIHJlY29yZHMgYnV0IG5vdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGlzIHdyb25nIGJ1dCB3ZSBnb3Qgc29tZXRoaW5nIGZvciB0aGUgdXNlcjogbm8gZXJyb3IgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJleHBlY3RlZFwiLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzLCBcInJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdFwiLCB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgYSB0cnVuY2F0ZWQgemlwIG9yIGNvbXBsZXRlIGdhcmJhZ2UuXG4gICAgICAgICAgICAvLyBBIFwiTE9DQUxfRklMRV9IRUFERVJcIiBpcyBub3QgcmVxdWlyZWQgYXQgdGhlIGJlZ2lubmluZyAoYXV0b1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlibGUgemlwIGZvciBleGFtcGxlKSBidXQgaXQgY2FuIGdpdmUgYSBnb29kIGhpbnQuXG4gICAgICAgICAgICAvLyBJZiBhbiBhamF4IHJlcXVlc3Qgd2FzIHVzZWQgd2l0aG91dCByZXNwb25zZVR5cGUsIHdlIHdpbGwgYWxzb1xuICAgICAgICAgICAgLy8gZ2V0IHVucmVhZGFibGUgZGF0YS5cbiAgICAgICAgICAgIHZhciBpc0dhcmJhZ2UgPSAhdGhpcy5pc1NpZ25hdHVyZSgwLCBzaWcuTE9DQUxfRklMRV9IRUFERVIpO1xuXG4gICAgICAgICAgICBpZiAoaXNHYXJiYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgOiBpcyB0aGlzIGEgemlwIGZpbGUgPyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFTY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SKTtcbiAgICAgICAgICAgIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB0aGUgemlwNjQgRU9DRCByZWNvcmRcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NpZ25hdHVyZSh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIsIHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwiWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IG5vdCB3aGVyZSBleHBlY3RlZC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gdGhpcy5jZW50cmFsRGlyT2Zmc2V0ICsgdGhpcy5jZW50cmFsRGlyU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuemlwNjQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0ICs9IDIwOyAvLyBlbmQgb2YgY2VudHJhbCBkaXIgNjQgbG9jYXRvclxuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMTIgLyogc2hvdWxkIG5vdCBpbmNsdWRlIHRoZSBsZWFkaW5nIDEyIGJ5dGVzICovICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cmFCeXRlcyA9IGVuZE9mQ2VudHJhbERpck9mZnNldCAtIGV4cGVjdGVkRW5kT2ZDZW50cmFsRGlyT2Zmc2V0O1xuXG4gICAgICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGV4dHJhQnl0ZXMsIFwiZXh0cmEgYnl0ZXMgYXQgYmVnaW5uaW5nIG9yIHdpdGhpbiB6aXBmaWxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaWduYXR1cmUoZW5kT2ZDZW50cmFsRGlyT2Zmc2V0LCBzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb2Zmc2V0cyBzZWVtIHdyb25nLCBidXQgd2UgaGF2ZSBzb21ldGhpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICAgICAgICAgICAgLy8gU2/igKYgd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyB3cm9uZywgdXBkYXRlIHRoZSBcInplcm9cIiBvZiB0aGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIGRhdGEgaGFzIGJlZW4gcHJlcGVuZGVkIChjcnggZmlsZXMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIuemVybyA9IGV4dHJhQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIgKyBNYXRoLmFicyhleHRyYUJ5dGVzKSArIFwiIGJ5dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlYWRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlckZvcihkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG4iXSwibmFtZXMiOlsicmVhZGVyRm9yIiwicmVxdWlyZSIsInV0aWxzIiwic2lnIiwiWmlwRW50cnkiLCJzdXBwb3J0IiwiWmlwRW50cmllcyIsImxvYWRPcHRpb25zIiwiZmlsZXMiLCJwcm90b3R5cGUiLCJjaGVja1NpZ25hdHVyZSIsImV4cGVjdGVkU2lnbmF0dXJlIiwicmVhZGVyIiwicmVhZEFuZENoZWNrU2lnbmF0dXJlIiwiaW5kZXgiLCJzaWduYXR1cmUiLCJyZWFkU3RyaW5nIiwiRXJyb3IiLCJwcmV0dHkiLCJpc1NpZ25hdHVyZSIsImFza2VkSW5kZXgiLCJjdXJyZW50SW5kZXgiLCJzZXRJbmRleCIsInJlc3VsdCIsInJlYWRCbG9ja0VuZE9mQ2VudHJhbCIsImRpc2tOdW1iZXIiLCJyZWFkSW50IiwiZGlza1dpdGhDZW50cmFsRGlyU3RhcnQiLCJjZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2siLCJjZW50cmFsRGlyUmVjb3JkcyIsImNlbnRyYWxEaXJTaXplIiwiY2VudHJhbERpck9mZnNldCIsInppcENvbW1lbnRMZW5ndGgiLCJ6aXBDb21tZW50IiwicmVhZERhdGEiLCJkZWNvZGVQYXJhbVR5cGUiLCJ1aW50OGFycmF5IiwiZGVjb2RlQ29udGVudCIsInRyYW5zZm9ybVRvIiwiZGVjb2RlRmlsZU5hbWUiLCJyZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCIsInppcDY0RW5kT2ZDZW50cmFsU2l6ZSIsInNraXAiLCJ6aXA2NEV4dGVuc2libGVEYXRhIiwiZXh0cmFEYXRhU2l6ZSIsImV4dHJhRmllbGRJZCIsImV4dHJhRmllbGRMZW5ndGgiLCJleHRyYUZpZWxkVmFsdWUiLCJpZCIsImxlbmd0aCIsInZhbHVlIiwicmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yIiwiZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCIsInJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIiLCJkaXNrc0NvdW50IiwicmVhZExvY2FsRmlsZXMiLCJpIiwiZmlsZSIsImxvY2FsSGVhZGVyT2Zmc2V0IiwiTE9DQUxfRklMRV9IRUFERVIiLCJyZWFkTG9jYWxQYXJ0IiwiaGFuZGxlVVRGOCIsInByb2Nlc3NBdHRyaWJ1dGVzIiwicmVhZENlbnRyYWxEaXIiLCJDRU5UUkFMX0ZJTEVfSEVBREVSIiwiemlwNjQiLCJyZWFkQ2VudHJhbFBhcnQiLCJwdXNoIiwicmVhZEVuZE9mQ2VudHJhbCIsIm9mZnNldCIsImxhc3RJbmRleE9mU2lnbmF0dXJlIiwiQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiaXNHYXJiYWdlIiwiZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IiwiTUFYX1ZBTFVFXzE2QklUUyIsIk1BWF9WQUxVRV8zMkJJVFMiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9MT0NBVE9SIiwiWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EIiwiZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQiLCJleHRyYUJ5dGVzIiwiemVybyIsIk1hdGgiLCJhYnMiLCJwcmVwYXJlUmVhZGVyIiwiZGF0YSIsImxvYWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/zipEntries.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/zipEntry.js":
/*!************************************************!*\
  !*** ../../node_modules/jszip/lib/zipEntry.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/../../node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/../../node_modules/jszip/lib/compressedObject.js\");\nvar crc32fn = __webpack_require__(/*! ./crc32 */ \"(ssr)/../../node_modules/jszip/lib/crc32.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/../../node_modules/jszip/lib/utf8.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"(ssr)/../../node_modules/jszip/lib/compressions.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/../../node_modules/jszip/lib/support.js\");\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */ var findCompression = function(compressionMethod) {\n    for(var method in compressions){\n        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */ isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */ useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) {\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */ processAttributes: function() {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n        if (madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n        if (madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;\n        // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === \"/\") {\n            this.dir = true;\n        }\n    },\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */ parseZIP64ExtraField: function() {\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n        while(reader.index + 4 < end){\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */ handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */ findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */ findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDLGtGQUFvQjtBQUM1QyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyw0REFBUztBQUM3QixJQUFJRSxtQkFBbUJGLG1CQUFPQSxDQUFDLGtGQUFvQjtBQUNuRCxJQUFJRyxVQUFVSCxtQkFBT0EsQ0FBQyw0REFBUztBQUMvQixJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQywwREFBUTtBQUMzQixJQUFJSyxlQUFlTCxtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDM0MsSUFBSU0sVUFBVU4sbUJBQU9BLENBQUMsZ0VBQVc7QUFFakMsSUFBSU8sY0FBYztBQUNsQixJQUFJQyxlQUFlO0FBRW5COzs7O0NBSUMsR0FDRCxJQUFJQyxrQkFBa0IsU0FBU0MsaUJBQWlCO0lBQzVDLElBQUssSUFBSUMsVUFBVU4sYUFBYztRQUM3QixJQUFJLENBQUNPLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNWLGNBQWNNLFNBQVM7WUFDN0Q7UUFDSjtRQUNBLElBQUlOLFlBQVksQ0FBQ00sT0FBTyxDQUFDSyxLQUFLLEtBQUtOLG1CQUFtQjtZQUNsRCxPQUFPTCxZQUFZLENBQUNNLE9BQU87UUFDL0I7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBLHFCQUFxQjtBQUNyQjs7Ozs7Q0FLQyxHQUNELFNBQVNNLFNBQVNDLE9BQU8sRUFBRUMsV0FBVztJQUNsQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNDLFdBQVcsR0FBR0E7QUFDdkI7QUFDQUYsU0FBU0osU0FBUyxHQUFHO0lBQ2pCOzs7S0FHQyxHQUNETyxhQUFhO1FBQ1QsZUFBZTtRQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxNQUFLLE1BQU87SUFDdkM7SUFDQTs7O0tBR0MsR0FDREMsU0FBUztRQUNMLGdCQUFnQjtRQUNo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LElBQUk7Z0JBQ25ELE9BQU87WUFDWDtZQUVBLE9BQU96QixLQUFLdUUsVUFBVSxDQUFDZCxZQUFZOUIsUUFBUSxDQUFDcUQsV0FBV2QsTUFBTSxHQUFHO1FBQ3BFO1FBQ0EsT0FBTztJQUNYO0lBRUE7OztLQUdDLEdBQ0RZLDhCQUE4QjtRQUMxQixJQUFJRyxnQkFBZ0IsSUFBSSxDQUFDekIsV0FBVyxDQUFDLE9BQU87UUFDNUMsSUFBSXlCLGVBQWU7WUFDZixJQUFJeEIsY0FBYzlELFVBQVVzRixjQUFjdkIsS0FBSztZQUUvQyxnQkFBZ0I7WUFDaEIsSUFBSUQsWUFBWWhDLE9BQU8sQ0FBQyxPQUFPLEdBQUc7Z0JBQzlCLE9BQU87WUFDWDtZQUVBLDZEQUE2RDtZQUM3RCxJQUFJMUIsUUFBUSxJQUFJLENBQUNpRCxXQUFXLE1BQU1TLFlBQVloQyxPQUFPLENBQUMsSUFBSTtnQkFDdEQsT0FBTztZQUNYO1lBRUEsT0FBT3pCLEtBQUt1RSxVQUFVLENBQUNkLFlBQVk5QixRQUFRLENBQUNzRCxjQUFjZixNQUFNLEdBQUc7UUFDdkU7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBZ0IsT0FBT0MsT0FBTyxHQUFHdEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJ5LmpzPzA5NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZShcIi4vcmVhZGVyL3JlYWRlckZvclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIENvbXByZXNzZWRPYmplY3QgPSByZXF1aXJlKFwiLi9jb21wcmVzc2VkT2JqZWN0XCIpO1xudmFyIGNyYzMyZm4gPSByZXF1aXJlKFwiLi9jcmMzMlwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbnNcIik7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoXCIuL3N1cHBvcnRcIik7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbXByZXNzaW9ucywgbWV0aG9kKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzaW9uc1ttZXRob2RdLm1hZ2ljID09PSBjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzaW9uc1ttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8gY2xhc3MgWmlwRW50cnkge3t7XG4vKipcbiAqIEFuIGVudHJ5IGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvZiB0aGUgY3VycmVudCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGxvYWRPcHRpb25zIE9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gWmlwRW50cnkob3B0aW9ucywgbG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucztcbn1cblppcEVudHJ5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzYXkgaWYgdGhlIGZpbGUgaXMgZW5jcnlwdGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGUgaXMgZW5jcnlwdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFbmNyeXB0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBiaXQgMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDAwMDEpID09PSAweDAwMDE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzYXkgaWYgdGhlIGZpbGUgaGFzIHV0Zi04IGZpbGVuYW1lL2NvbW1lbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZW5hbWUvY29tbWVudCBpcyBpbiB1dGYtOCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHVzZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBiaXQgMTEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwODAwKSA9PT0gMHgwODAwO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgbG9jYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZExvY2FsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aDtcblxuICAgICAgICAvLyB3ZSBhbHJlYWR5IGtub3cgZXZlcnl0aGluZyBmcm9tIHRoZSBjZW50cmFsIGRpciAhXG4gICAgICAgIC8vIElmIHRoZSBjZW50cmFsIGRpciBkYXRhIGFyZSBmYWxzZSwgd2UgYXJlIGRvb21lZC5cbiAgICAgICAgLy8gT24gdGhlIGJyaWdodCBzaWRlLCB0aGUgbG9jYWwgcGFydCBpcyBzY2FyeSAgOiB6aXA2NCwgZGF0YSBkZXNjcmlwdG9ycywgYm90aCwgZXRjLlxuICAgICAgICAvLyBUaGUgbGVzcyBkYXRhIHdlIGdldCBoZXJlLCB0aGUgbW9yZSByZWxpYWJsZSB0aGlzIHNob3VsZCBiZS5cbiAgICAgICAgLy8gTGV0J3Mgc2tpcCB0aGUgd2hvbGUgaGVhZGVyIGFuZCBkYXNoIHRvIHRoZSBkYXRhICFcbiAgICAgICAgcmVhZGVyLnNraXAoMjIpO1xuICAgICAgICAvLyBpbiBzb21lIHppcCBjcmVhdGVkIG9uIHdpbmRvd3MsIHRoZSBmaWxlbmFtZSBzdG9yZWQgaW4gdGhlIGNlbnRyYWwgZGlyIGNvbnRhaW5zIFxcIGluc3RlYWQgb2YgLy5cbiAgICAgICAgLy8gU3RyYW5nZWx5LCB0aGUgZmlsZW5hbWUgaGVyZSBpcyBPSy5cbiAgICAgICAgLy8gSSB3b3VsZCBsb3ZlIHRvIHRyZWF0IHRoZXNlIHppcCBmaWxlcyBhcyBjb3JydXB0ZWQgKHNlZSBodHRwOi8vd3d3LmluZm8temlwLm9yZy9GQVEuaHRtbCNiYWNrc2xhc2hlc1xuICAgICAgICAvLyBvciBBUFBOT1RFIzQuNC4xNy4xLCBcIkFsbCBzbGFzaGVzIE1VU1QgYmUgZm9yd2FyZCBzbGFzaGVzICcvJ1wiKSBidXQgdGhlcmUgYXJlIGEgbG90IG9mIGJhZCB6aXAgZ2VuZXJhdG9ycy4uLlxuICAgICAgICAvLyBTZWFyY2ggXCJ1bnppcCBtaXNtYXRjaGluZyBcImxvY2FsXCIgZmlsZW5hbWUgY29udGludWluZyB3aXRoIFwiY2VudHJhbFwiIGZpbGVuYW1lIHZlcnNpb25cIiBvblxuICAgICAgICAvLyB0aGUgaW50ZXJuZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEkgdGhpbmsgSSBzZWUgdGhlIGxvZ2ljIGhlcmUgOiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgaXMgdXNlZCB0byBkaXNwbGF5XG4gICAgICAgIC8vIGNvbnRlbnQgYW5kIHRoZSBsb2NhbCBkaXJlY3RvcnkgaXMgdXNlZCB0byBleHRyYWN0IHRoZSBmaWxlcy4gTWl4aW5nIC8gYW5kIFxcXG4gICAgICAgIC8vIG1heSBiZSB1c2VkIHRvIGRpc3BsYXkgXFwgdG8gd2luZG93cyB1c2VycyBhbmQgdXNlIC8gd2hlbiBleHRyYWN0aW5nIHRoZSBmaWxlcy5cbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhpcyBsZWFkIGFsc28gdG8gc29tZSBpc3N1ZXMgOiBodHRwOi8vc2VjbGlzdHMub3JnL2Z1bGxkaXNjbG9zdXJlLzIwMDkvU2VwLzM5NFxuICAgICAgICB0aGlzLmZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTsgLy8gY2FuJ3QgYmUgc3VyZSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGNlbnRyYWwgZGlyXG4gICAgICAgIC8vIHRoZSBmaWxlTmFtZSBpcyBzdG9yZWQgYXMgYmluYXJ5IGRhdGEsIHRoZSBoYW5kbGVVVEY4IG1ldGhvZCB3aWxsIHRha2UgY2FyZSBvZiB0aGUgZW5jb2RpbmcuXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHJlYWRlci5za2lwKGxvY2FsRXh0cmFGaWVsZHNMZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSAtMSB8fCB0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgb3IgY29ycnVwdGVkIHppcCA6IGRpZG4ndCBnZXQgZW5vdWdoIGluZm9ybWF0aW9uIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXByZXNzaW9uID0gZmluZENvbXByZXNzaW9uKHRoaXMuY29tcHJlc3Npb25NZXRob2QpO1xuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IG51bGwpIHsgLy8gbm8gY29tcHJlc3Npb24gZm91bmRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHV0aWxzLnByZXR0eSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSArIFwiIHVua25vd24gKGlubmVyIGZpbGUgOiBcIiArIHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMuZmlsZU5hbWUpICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IENvbXByZXNzZWRPYmplY3QodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCBjb21wcmVzc2lvbiwgcmVhZGVyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkQ2VudHJhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB0aGlzLnZlcnNpb25NYWRlQnkgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgcmVhZGVyLnNraXAoMik7XG4gICAgICAgIC8vIHRoaXMudmVyc2lvbk5lZWRlZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmJpdEZsYWcgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHJlYWRlci5yZWFkU3RyaW5nKDIpO1xuICAgICAgICB0aGlzLmRhdGUgPSByZWFkZXIucmVhZERhdGUoKTtcbiAgICAgICAgdGhpcy5jcmMzMiA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB2YXIgZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IHJlYWRlci5yZWFkSW50KDQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aWxsIGJlIHJlYWQgaW4gdGhlIGxvY2FsIHBhcnQsIHNlZSB0aGUgY29tbWVudHMgdGhlcmVcbiAgICAgICAgcmVhZGVyLnNraXAoZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICB0aGlzLnJlYWRFeHRyYUZpZWxkcyhyZWFkZXIpO1xuICAgICAgICB0aGlzLnBhcnNlWklQNjRFeHRyYUZpZWxkKHJlYWRlcik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnQgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgYW5kIGdldCB0aGUgdW5peC9kb3MgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdmFyIG1hZGVCeSA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdGhlIERPUyBkaXJlY3RvcnkgZmxhZyBzZXQuXG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGl0IGluIHRoZSBET1MgYW5kIFVOSVggcGVybWlzc2lvbnNcbiAgICAgICAgLy8gYnV0IHNvbWUgdW5rbm93biBwbGF0Zm9ybSBjb3VsZCBzZXQgaXQgYXMgYSBjb21wYXRpYmlsaXR5IGZsYWcuXG4gICAgICAgIHRoaXMuZGlyID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgwMDEwID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9ET1MpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IDYgYml0cyAoMCB0byA1KVxuICAgICAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4M0Y7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfVU5JWCkge1xuICAgICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSAodGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAgICAgICAgIC8vIHRoZSBvY3RhbCBwZXJtaXNzaW9ucyBhcmUgaW4gKHRoaXMudW5peFBlcm1pc3Npb25zICYgMHgwMUZGKS50b1N0cmluZyg4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhaWwgc2FmZSA6IGlmIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC8gaXQgcHJvYmFibHkgbWVhbnMgYSBmb2xkZXJcbiAgICAgICAgaWYgKCF0aGlzLmRpciAmJiB0aGlzLmZpbGVOYW1lU3RyLnNsaWNlKC0xKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgWklQNjQgZXh0cmEgZmllbGQgYW5kIG1lcmdlIHRoZSBpbmZvIGluIHRoZSBjdXJyZW50IFppcEVudHJ5LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBiZSBzb21ldGhpbmcsIHByZXBhcmluZyB0aGUgZXh0cmEgcmVhZGVyXG4gICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IHJlYWRlci5pbmRleCArIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHJlYWRlci5pbmRleCArIDQgPCBlbmQpIHtcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlID0gcmVhZGVyLnJlYWREYXRhKGV4dHJhRmllbGRMZW5ndGgpO1xuXG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWRlci5zZXRJbmRleChlbmQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgYW4gVVRGOCB0cmFuc2Zvcm1hdGlvbiBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgaGFuZGxlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgaWYgKHRoaXMudXNlVVRGOCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVDb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cGF0aCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHVwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHVwYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZUJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGZpbGVOYW1lQnl0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVjb21tZW50ID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50KCk7XG4gICAgICAgICAgICBpZiAodWNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdWNvbW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVDb21tZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShjb21tZW50Qnl0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSB1bmljb2RlIHBhdGggZGVjbGFyZWQgaW4gdGhlIGV4dHJhIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgdW5pY29kZSBwYXRoLCBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVwYXRoRmllbGQgPSB0aGlzLmV4dHJhRmllbGRzWzB4NzA3NV07XG4gICAgICAgIGlmICh1cGF0aEZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodXBhdGhGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGZpbGVuYW1lIGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVOYW1lKSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVwYXRoRmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSB1bmljb2RlIGNvbW1lbnQgZGVjbGFyZWQgaW4gdGhlIGV4dHJhIGZpZWxkLCBpZiBhbnkuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgdW5pY29kZSBjb21tZW50LCBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmaW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVjb21tZW50RmllbGQgPSB0aGlzLmV4dHJhRmllbGRzWzB4NjM3NV07XG4gICAgICAgIGlmICh1Y29tbWVudEZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodWNvbW1lbnRGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGNvbW1lbnQgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZUNvbW1lbnQpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodWNvbW1lbnRGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cnk7XG4iXSwibmFtZXMiOlsicmVhZGVyRm9yIiwicmVxdWlyZSIsInV0aWxzIiwiQ29tcHJlc3NlZE9iamVjdCIsImNyYzMyZm4iLCJ1dGY4IiwiY29tcHJlc3Npb25zIiwic3VwcG9ydCIsIk1BREVfQllfRE9TIiwiTUFERV9CWV9VTklYIiwiZmluZENvbXByZXNzaW9uIiwiY29tcHJlc3Npb25NZXRob2QiLCJtZXRob2QiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtYWdpYyIsIlppcEVudHJ5Iiwib3B0aW9ucyIsImxvYWRPcHRpb25zIiwiaXNFbmNyeXB0ZWQiLCJiaXRGbGFnIiwidXNlVVRGOCIsInJlYWRMb2NhbFBhcnQiLCJyZWFkZXIiLCJjb21wcmVzc2lvbiIsImxvY2FsRXh0cmFGaWVsZHNMZW5ndGgiLCJza2lwIiwiZmlsZU5hbWVMZW5ndGgiLCJyZWFkSW50IiwiZmlsZU5hbWUiLCJyZWFkRGF0YSIsImNvbXByZXNzZWRTaXplIiwidW5jb21wcmVzc2VkU2l6ZSIsIkVycm9yIiwicHJldHR5IiwidHJhbnNmb3JtVG8iLCJkZWNvbXByZXNzZWQiLCJjcmMzMiIsInJlYWRDZW50cmFsUGFydCIsInZlcnNpb25NYWRlQnkiLCJyZWFkU3RyaW5nIiwiZGF0ZSIsInJlYWREYXRlIiwiZXh0cmFGaWVsZHNMZW5ndGgiLCJmaWxlQ29tbWVudExlbmd0aCIsImRpc2tOdW1iZXJTdGFydCIsImludGVybmFsRmlsZUF0dHJpYnV0ZXMiLCJleHRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwibG9jYWxIZWFkZXJPZmZzZXQiLCJyZWFkRXh0cmFGaWVsZHMiLCJwYXJzZVpJUDY0RXh0cmFGaWVsZCIsImZpbGVDb21tZW50IiwicHJvY2Vzc0F0dHJpYnV0ZXMiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyIsIm1hZGVCeSIsImRpciIsImZpbGVOYW1lU3RyIiwic2xpY2UiLCJleHRyYUZpZWxkcyIsImV4dHJhUmVhZGVyIiwidmFsdWUiLCJNQVhfVkFMVUVfMzJCSVRTIiwiZW5kIiwiaW5kZXgiLCJleHRyYUZpZWxkSWQiLCJleHRyYUZpZWxkTGVuZ3RoIiwiZXh0cmFGaWVsZFZhbHVlIiwiaWQiLCJsZW5ndGgiLCJzZXRJbmRleCIsImhhbmRsZVVURjgiLCJkZWNvZGVQYXJhbVR5cGUiLCJ1aW50OGFycmF5IiwidXRmOGRlY29kZSIsImZpbGVDb21tZW50U3RyIiwidXBhdGgiLCJmaW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoIiwiZmlsZU5hbWVCeXRlQXJyYXkiLCJkZWNvZGVGaWxlTmFtZSIsInVjb21tZW50IiwiZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCIsImNvbW1lbnRCeXRlQXJyYXkiLCJ1cGF0aEZpZWxkIiwidWNvbW1lbnRGaWVsZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/zipEntry.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/jszip/lib/zipObject.js":
/*!*************************************************!*\
  !*** ../../node_modules/jszip/lib/zipObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/../../node_modules/jszip/lib/stream/StreamHelper.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/DataWorker.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/../../node_modules/jszip/lib/utf8.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/../../node_modules/jszip/lib/compressedObject.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/../../node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */ var ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression: options.compression,\n        compressionOptions: options.compressionOptions\n    };\n};\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */ internalStream: function(type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n            var isUnicodeString = !this._dataBinary;\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n        return new StreamHelper(result, outputType, \"\");\n    },\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */ async: function(type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */ nodeStream: function(type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */ _compressWorker: function(compression, compressionOptions) {\n        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if (!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */ _decompressWorker: function() {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\nvar removedMethods = [\n    \"asText\",\n    \"asBinary\",\n    \"asNodeBuffer\",\n    \"asUint8Array\",\n    \"asArrayBuffer\"\n];\nvar removedFn = function() {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\nfor(var i = 0; i < removedMethods.length; i++){\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQyx3RkFBdUI7QUFDbEQsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQXFCO0FBQzlDLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDLDBEQUFRO0FBQzNCLElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUMsa0ZBQW9CO0FBQ25ELElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUMsMEZBQXdCO0FBRXBEOzs7Ozs7Q0FNQyxHQUNELElBQUlLLFlBQVksU0FBU0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE9BQU87SUFDeEMsSUFBSSxDQUFDRixJQUFJLEdBQUdBO0lBQ1osSUFBSSxDQUFDRyxHQUFHLEdBQUdELFFBQVFDLEdBQUc7SUFDdEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdGLFFBQVFFLElBQUk7SUFDeEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdILFFBQVFHLE9BQU87SUFDOUIsSUFBSSxDQUFDQyxlQUFlLEdBQUdKLFFBQVFJLGVBQWU7SUFDOUMsSUFBSSxDQUFDQyxjQUFjLEdBQUdMLFFBQVFLLGNBQWM7SUFFNUMsSUFBSSxDQUFDQyxLQUFLLEdBQUdQO0lBQ2IsSUFBSSxDQUFDUSxXQUFXLEdBQUdQLFFBQVFRLE1BQU07SUFDakMsNEJBQTRCO0lBQzVCLElBQUksQ0FBQ1IsT0FBTyxHQUFHO1FBQ1hTLGFBQWNULFFBQVFTLFdBQVc7UUFDakNDLG9CQUFxQlYsUUFBUVUsa0JBQWtCO0lBQ25EO0FBQ0o7QUFFQWIsVUFBVWMsU0FBUyxHQUFHO0lBQ2xCOzs7O0tBSUMsR0FDREMsZ0JBQWdCLFNBQVVDLElBQUk7UUFDMUIsSUFBSUMsU0FBUyxNQUFNQyxhQUFhO1FBQ2hDLElBQUk7WUFDQSxJQUFJLENBQUNGLE1BQU07Z0JBQ1AsTUFBTSxJQUFJRyxNQUFNO1lBQ3BCO1lBQ0FELGFBQWFGLEtBQUtJLFdBQVc7WUFDN0IsSUFBSUMsbUJBQW1CSCxlQUFlLFlBQVlBLGVBQWU7WUFDakUsSUFBSUEsZUFBZSxrQkFBa0JBLGVBQWUsUUFBUTtnQkFDeERBLGFBQWE7WUFDakI7WUFDQUQsU0FBUyxJQUFJLENBQUNLLGlCQUFpQjtZQUUvQixJQUFJQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUNiLFdBQVc7WUFFdkMsSUFBSWEsbUJBQW1CLENBQUNGLGtCQUFrQjtnQkFDdENKLFNBQVNBLE9BQU9PLElBQUksQ0FBQyxJQUFJM0IsS0FBSzRCLGdCQUFnQjtZQUNsRDtZQUNBLElBQUksQ0FBQ0YsbUJBQW1CRixrQkFBa0I7Z0JBQ3RDSixTQUFTQSxPQUFPTyxJQUFJLENBQUMsSUFBSTNCLEtBQUs2QixnQkFBZ0I7WUFDbEQ7UUFDSixFQUFFLE9BQU9DLEdBQUc7WUFDUlYsU0FBUyxJQUFJbEIsY0FBYztZQUMzQmtCLE9BQU9XLEtBQUssQ0FBQ0Q7UUFDakI7UUFFQSxPQUFPLElBQUlqQyxhQUFhdUIsUUFBUUMsWUFBWTtJQUNoRDtJQUVBOzs7OztLQUtDLEdBQ0RXLE9BQU8sU0FBVWIsSUFBSSxFQUFFYyxRQUFRO1FBQzNCLE9BQU8sSUFBSSxDQUFDZixjQUFjLENBQUNDLE1BQU1lLFVBQVUsQ0FBQ0Q7SUFDaEQ7SUFFQTs7Ozs7S0FLQyxHQUNERSxZQUFZLFNBQVVoQixJQUFJLEVBQUVjLFFBQVE7UUFDaEMsT0FBTyxJQUFJLENBQUNmLGNBQWMsQ0FBQ0MsUUFBUSxjQUFjaUIsY0FBYyxDQUFDSDtJQUNwRTtJQUVBOzs7Ozs7S0FNQyxHQUNESSxpQkFBaUIsU0FBVXRCLFdBQVcsRUFBRUMsa0JBQWtCO1FBQ3RELElBQ0ksSUFBSSxDQUFDSixLQUFLLFlBQVlYLG9CQUN0QixJQUFJLENBQUNXLEtBQUssQ0FBQ0csV0FBVyxDQUFDdUIsS0FBSyxLQUFLdkIsWUFBWXVCLEtBQUssRUFDcEQ7WUFDRSxPQUFPLElBQUksQ0FBQzFCLEtBQUssQ0FBQzJCLG1CQUFtQjtRQUN6QyxPQUFPO1lBQ0gsSUFBSW5CLFNBQVMsSUFBSSxDQUFDSyxpQkFBaUI7WUFDbkMsSUFBRyxDQUFDLElBQUksQ0FBQ1osV0FBVyxFQUFFO2dCQUNsQk8sU0FBU0EsT0FBT08sSUFBSSxDQUFDLElBQUkzQixLQUFLNEIsZ0JBQWdCO1lBQ2xEO1lBQ0EsT0FBTzNCLGlCQUFpQnVDLGdCQUFnQixDQUFDcEIsUUFBUUwsYUFBYUM7UUFDbEU7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRFMsbUJBQW9CO1FBQ2hCLElBQUksSUFBSSxDQUFDYixLQUFLLFlBQVlYLGtCQUFrQjtZQUN4QyxPQUFPLElBQUksQ0FBQ1csS0FBSyxDQUFDNkIsZ0JBQWdCO1FBQ3RDLE9BQU8sSUFBSSxJQUFJLENBQUM3QixLQUFLLFlBQVlWLGVBQWU7WUFDNUMsT0FBTyxJQUFJLENBQUNVLEtBQUs7UUFDckIsT0FBTztZQUNILE9BQU8sSUFBSWIsV0FBVyxJQUFJLENBQUNhLEtBQUs7UUFDcEM7SUFDSjtBQUNKO0FBRUEsSUFBSThCLGlCQUFpQjtJQUFDO0lBQVU7SUFBWTtJQUFnQjtJQUFnQjtDQUFnQjtBQUM1RixJQUFJQyxZQUFZO0lBQ1osTUFBTSxJQUFJckIsTUFBTTtBQUNwQjtBQUVBLElBQUksSUFBSXNCLElBQUksR0FBR0EsSUFBSUYsZUFBZUcsTUFBTSxFQUFFRCxJQUFLO0lBQzNDekMsVUFBVWMsU0FBUyxDQUFDeUIsY0FBYyxDQUFDRSxFQUFFLENBQUMsR0FBR0Q7QUFDN0M7QUFDQUcsT0FBT0MsT0FBTyxHQUFHNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AamFydmlzL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcz9hMjMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZShcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgc2ltcGxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBmaWxlIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICovXG52YXIgWmlwT2JqZWN0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kaXIgPSBvcHRpb25zLmRpcjtcbiAgICB0aGlzLmRhdGUgPSBvcHRpb25zLmRhdGU7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0aW9ucy5jb21tZW50O1xuICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gb3B0aW9ucy51bml4UGVybWlzc2lvbnM7XG4gICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG9wdGlvbnMuZG9zUGVybWlzc2lvbnM7XG5cbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9kYXRhQmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgLy8ga2VlcCBvbmx5IHRoZSBjb21wcmVzc2lvblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgY29tcHJlc3Npb24gOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9uc1xuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnRlcm5hbCBzdHJlYW0gZm9yIHRoZSBjb250ZW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHJldHVybiBTdHJlYW1IZWxwZXIgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgYXNrVW5pY29kZVN0cmluZyA9IG91dHB1dFR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3V0cHV0VHlwZSA9PT0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBpZiAob3V0cHV0VHlwZSA9PT0gXCJiaW5hcnlzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dFR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO1xuXG4gICAgICAgICAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gIXRoaXMuX2RhdGFCaW5hcnk7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaWNvZGVTdHJpbmcgJiYgIWFza1VuaWNvZGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShuZXcgdXRmOC5VdGY4RW5jb2RlV29ya2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1VuaWNvZGVTdHJpbmcgJiYgYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhEZWNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcihyZXN1bHQsIG91dHB1dFR5cGUsIFwiXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBjb250ZW50IGluIHRoZSBhc2tlZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGUgcHJvbWlzZSBvZiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSkuYWNjdW11bGF0ZShvblVwZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgYXMgYSBub2RlanMgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgYSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggaW50ZXJuYWwgdXBkYXRlLlxuICAgICAqIEByZXR1cm4gU3RyZWFtIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgbm9kZVN0cmVhbTogZnVuY3Rpb24gKHR5cGUsIG9uVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR5cGUgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBvYmplY3QgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY29tcHJlc3NpbmcuXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uIChjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0ICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbXByZXNzaW9uLm1hZ2ljID09PSBjb21wcmVzc2lvbi5tYWdpY1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICBpZighdGhpcy5fZGF0YUJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE9iamVjdC5jcmVhdGVXb3JrZXJGcm9tKHJlc3VsdCwgY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHdvcmtlciBmb3IgdGhlIGRlY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiBXb3JrZXIgdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBfZGVjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIEdlbmVyaWNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHJlbW92ZWRNZXRob2RzID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdO1xudmFyIHJlbW92ZWRGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbn07XG5cbmZvcih2YXIgaSA9IDA7IGkgPCByZW1vdmVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIFppcE9iamVjdC5wcm90b3R5cGVbcmVtb3ZlZE1ldGhvZHNbaV1dID0gcmVtb3ZlZEZuO1xufVxubW9kdWxlLmV4cG9ydHMgPSBaaXBPYmplY3Q7XG4iXSwibmFtZXMiOlsiU3RyZWFtSGVscGVyIiwicmVxdWlyZSIsIkRhdGFXb3JrZXIiLCJ1dGY4IiwiQ29tcHJlc3NlZE9iamVjdCIsIkdlbmVyaWNXb3JrZXIiLCJaaXBPYmplY3QiLCJuYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJkaXIiLCJkYXRlIiwiY29tbWVudCIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwiX2RhdGEiLCJfZGF0YUJpbmFyeSIsImJpbmFyeSIsImNvbXByZXNzaW9uIiwiY29tcHJlc3Npb25PcHRpb25zIiwicHJvdG90eXBlIiwiaW50ZXJuYWxTdHJlYW0iLCJ0eXBlIiwicmVzdWx0Iiwib3V0cHV0VHlwZSIsIkVycm9yIiwidG9Mb3dlckNhc2UiLCJhc2tVbmljb2RlU3RyaW5nIiwiX2RlY29tcHJlc3NXb3JrZXIiLCJpc1VuaWNvZGVTdHJpbmciLCJwaXBlIiwiVXRmOEVuY29kZVdvcmtlciIsIlV0ZjhEZWNvZGVXb3JrZXIiLCJlIiwiZXJyb3IiLCJhc3luYyIsIm9uVXBkYXRlIiwiYWNjdW11bGF0ZSIsIm5vZGVTdHJlYW0iLCJ0b05vZGVqc1N0cmVhbSIsIl9jb21wcmVzc1dvcmtlciIsIm1hZ2ljIiwiZ2V0Q29tcHJlc3NlZFdvcmtlciIsImNyZWF0ZVdvcmtlckZyb20iLCJnZXRDb250ZW50V29ya2VyIiwicmVtb3ZlZE1ldGhvZHMiLCJyZW1vdmVkRm4iLCJpIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/jszip/lib/zipObject.js\n");

/***/ })

};
;